# Qué harás en esta etapa 1/5: Bienvenido

Proyecto: [Centro de servicio Hypercar](https://hyperskill.org/projects/85)

866 usuarios resolvieron esta etapa. La última finalización fue hace 1 día .

Etapas completadas: **0/5**



- **Temas que necesitas aprender para completar la etapa actual:**

- [Conceptos básicos de las expresiones regulares](https://hyperskill.org/projects/85/stages/470/preview#)

[Programación de computadoras](https://hyperskill.org/projects/85/stages/470/preview#)

[Introducción al pensamiento computacional](https://hyperskill.org/projects/85/stages/470/preview#)

[Componentes del pensamiento computacional](https://hyperskill.org/projects/85/stages/470/preview#)

[Que es un error](https://hyperskill.org/projects/85/stages/470/preview#)

[Introducción a la programación orientada a objetos](https://hyperskill.org/projects/85/stages/470/preview#)

[Inmutabilidad](https://hyperskill.org/projects/85/stages/470/preview#)

[Introducción a Python](https://hyperskill.org/projects/85/stages/470/preview#)

[Resumen del programa básico](https://hyperskill.org/projects/85/stages/470/preview#)

[Programas multilínea](https://hyperskill.org/projects/85/stages/470/preview#)

[Ejecución del programa](https://hyperskill.org/projects/85/stages/470/preview#)

[PEP 8](https://hyperskill.org/projects/85/stages/470/preview#)

[Comentarios](https://hyperskill.org/projects/85/stages/470/preview#)

[Tipos de datos básicos](https://hyperskill.org/projects/85/stages/470/preview#)

[Aritmética de enteros](https://hyperskill.org/projects/85/stages/470/preview#)

[Cotizaciones y cadenas de varias líneas](https://hyperskill.org/projects/85/stages/470/preview#)

[Secuencias de escape](https://hyperskill.org/projects/85/stages/470/preview#)

[Variables](https://hyperskill.org/projects/85/stages/470/preview#)

[Nombrar variables](https://hyperskill.org/projects/85/stages/470/preview#)

[Tomando aportes](https://hyperskill.org/projects/85/stages/470/preview#)

[Formato de cadena](https://hyperskill.org/projects/85/stages/470/preview#)

[Programa con números](https://hyperskill.org/projects/85/stages/470/preview#)

[Lista](https://hyperskill.org/projects/85/stages/470/preview#)

[Índices](https://hyperskill.org/projects/85/stages/470/preview#)

[Invocar una función](https://hyperskill.org/projects/85/stages/470/preview#)

[Declarar una función](https://hyperskill.org/projects/85/stages/470/preview#)

[Alcances](https://hyperskill.org/projects/85/stages/470/preview#)

[Métodos básicos de cadena](https://hyperskill.org/projects/85/stages/470/preview#)

[lógica booleana](https://hyperskill.org/projects/85/stages/470/preview#)

[Comparaciones](https://hyperskill.org/projects/85/stages/470/preview#)

[Prueba de identidad](https://hyperskill.org/projects/85/stages/470/preview#)

[Diccionario](https://hyperskill.org/projects/85/stages/470/preview#)

[Argumentos](https://hyperskill.org/projects/85/stages/470/preview#)

[Operaciones con lista](https://hyperskill.org/projects/85/stages/470/preview#)

[Tupla](https://hyperskill.org/projects/85/stages/470/preview#)

[Si declaración](https://hyperskill.org/projects/85/stages/470/preview#)

[Otra declaración](https://hyperskill.org/projects/85/stages/470/preview#)

[Declaración de elif](https://hyperskill.org/projects/85/stages/470/preview#)

[En bucle](https://hyperskill.org/projects/85/stages/470/preview#)

[Descomposición funcional](https://hyperskill.org/projects/85/stages/470/preview#)

[Métodos de diccionario](https://hyperskill.org/projects/85/stages/470/preview#)

[Operaciones con diccionario](https://hyperskill.org/projects/85/stages/470/preview#)

[Objetos en Python](https://hyperskill.org/projects/85/stages/470/preview#)

[Argumentos predeterminados](https://hyperskill.org/projects/85/stages/470/preview#)

[Args](https://hyperskill.org/projects/85/stages/470/preview#)

[Dividir y unir](https://hyperskill.org/projects/85/stages/470/preview#)

[Módulo de carga](https://hyperskill.org/projects/85/stages/470/preview#)

[Crear módulo](https://hyperskill.org/projects/85/stages/470/preview#)

[Paquetes](https://hyperskill.org/projects/85/stages/470/preview#)

[Errores](https://hyperskill.org/projects/85/stages/470/preview#)

[Excepciones](https://hyperskill.org/projects/85/stages/470/preview#)

[Clase](https://hyperskill.org/projects/85/stages/470/preview#)

[Instancias de clase](https://hyperskill.org/projects/85/stages/470/preview#)

[Métodos](https://hyperskill.org/projects/85/stages/470/preview#)

[Bibliotecas](https://hyperskill.org/projects/85/stages/470/preview#)

[Frameworks](https://hyperskill.org/projects/85/stages/470/preview#)

[El concepto de patrones](https://hyperskill.org/projects/85/stages/470/preview#)

[AQUÍ](https://hyperskill.org/projects/85/stages/470/preview#)

[Conceptos básicos de PyCharm](https://hyperskill.org/projects/85/stages/470/preview#)

[Red mundial](https://hyperskill.org/projects/85/stages/470/preview#)

[Protocolo de Transferencia de Hipertexto](https://hyperskill.org/projects/85/stages/470/preview#)

[URL HTTP](https://hyperskill.org/projects/85/stages/470/preview#)

[Mensajes HTTP](https://hyperskill.org/projects/85/stages/470/preview#)

[desarrollo web](https://hyperskill.org/projects/85/stages/470/preview#)

[Conceptos básicos de HTML](https://hyperskill.org/projects/85/stages/470/preview#)

[Etiquetas y atributos](https://hyperskill.org/projects/85/stages/470/preview#)

[Introducción a los sistemas operativos](https://hyperskill.org/projects/85/stages/470/preview#)

[Tipos de archivo](https://hyperskill.org/projects/85/stages/470/preview#)

[Descripción general de la línea de comandos](https://hyperskill.org/projects/85/stages/470/preview#)

[Parámetros y opciones](https://hyperskill.org/projects/85/stages/470/preview#)

[Pepita](https://hyperskill.org/projects/85/stages/470/preview#)

[Ambiente virtual](https://hyperskill.org/projects/85/stages/470/preview#)

[Introducción a Django](https://hyperskill.org/projects/85/stages/470/preview#)

[Django MVC](https://hyperskill.org/projects/85/stages/470/preview#)

[Estructura del proyecto Django](https://hyperskill.org/projects/85/stages/470/preview#)

[Iniciar un proyecto](https://hyperskill.org/projects/85/stages/470/preview#)

[Lanzamiento del servidor web](https://hyperskill.org/projects/85/stages/470/preview#)

[Procesamiento de solicitudes](https://hyperskill.org/projects/85/stages/470/preview#)

Utilice el material de estos temas y las habilidades que ha aprendido para completar con éxito esta etapa del proyecto.



**Trabajará en lo siguiente en esta etapa del proyecto**

Implemente el primer controlador del servicio y salude a los clientes en la página de bienvenida.

Mostrar detalles ↓

![img](https://hyperskill.azureedge.net/static/img/discuss.de5d9a73.svg)

[Únase a un grupo de estudio para el proyecto Hypercar Service Center](https://hyperskill.org/projects/85/study-group)

Discuta su proyecto actual con otros alumnos y ayúdense unos a otros.

## Descripción

Hypercar Ltd es un fabricante de automóviles poco conocido. El año pasado fue todo un éxito para la empresa: ¡duplicaron sus beneficios y consiguieron vender unos diez mil coches! Cada vehículo Hypercar necesita ser reparado o reparado en algún momento, por lo que la compañía ha abierto varios centros de servicio. Después de abrir los centros, los gerentes pronto notaron que sus procedimientos operativos debían optimizarse para mejorar la experiencia del cliente. Para hacer esto, quieren una aplicación web que pueda manejar la gestión de colas y les gustaría que implementaras el sistema.

Lo lograrás creando un proyecto de Django llamado "hypercar" que contenga una aplicación de "tickets". Esta aplicación contará con un servidor que crea nuevos tickets para los clientes y asegura que la cola se ordene correctamente.

## Objetivos

Lo primero que debe hacer el sistema es saludar a todos los clientes del servicio, por lo que debe implementar una página de bienvenida que muestre el mensaje correcto.

Para enfatizar el texto, debe crear un `<h2>`elemento con el contenido `Welcome to the Hypercar service!`, como se muestra a continuación:

```html
<h2>Welcome to the Hypercar Service!</h2>
```

El proyecto tendrá varias URL para diferentes tareas, así que haga que esta página esté disponible en *<base_url> / welcome* , donde *<base_url>* es el host. Si inicia la aplicación en su computadora con el `python manage.py runserver`comando, el host será *localhost: 8000* .

Si el servidor devuelve la página en la dirección *http: // localhost: 8000 / welcome,* ¡puede estar seguro de que está funcionando correctamente!

La manipulación de datos de texto es una tarea bastante popular tanto en la programación como en la vida real. Por ejemplo, a menudo es posible que necesitemos analizar un texto, encontrar todas las cadenas específicas en un archivo, etc. El procesamiento de datos de texto puede ser un problema bastante complicado. Es por eso que existe una herramienta especial llamada expresiones regulares que lo hace más fácil y rápido.

## ¿Por qué expresiones regulares?

Una **expresión regular** ( **regex** o **regexp** para abreviar) es una secuencia de caracteres que describe un **patrón** común para un conjunto de cadenas. Estos patrones se pueden utilizar para buscar, editar y manipular textos. Pueden comprobar si una cadena completa o su subcadena coincide con el patrón dado o reemplazar la subcadena por otra.

¿Cuándo necesitamos tales patrones? Digamos que queremos obtener todos los archivos con la misma extensión (como * .pdf), o extraer todas las entradas de un nombre en particular en diferentes formas (por ejemplo, Edgar Poe, Edgar Allan Poe, EA Poe, etc.), todos direcciones de correo electrónico, o incluso encontrar todas las estructuras numéricas que denotan fechas (02/03/2020). Con las expresiones regulares, estas tareas se pueden realizar con una línea.

¿Cómo se ven esos patrones? Bueno, al principio, pueden parecer confusos, mire, por ejemplo, `\d+(\.\d)?` o `[a-zA-Z]`. Y a menudo son sustancialmente más largos. Sin embargo, comenzaremos con lo básico.

Las expresiones regulares pueden considerarse como una especie de sublenguaje compatible con la mayoría de los lenguajes de programación, pero existen algunas diferencias en la sintaxis llamadas **"sabores"** . En este tema, consideraremos las **expresiones regulares** de forma aislada de los lenguajes de programación para comprender la idea general.

Mientras aprende este tema, puede visitar el [sitio](https://regex101.com/) de expresiones regulares para jugar con expresiones regulares de nuestros ejemplos. Elija **PCRE** como sabor. Significa **P** ERL **C** ompatible **R** egular **E** xpressions que son el estándar más común en la práctica.

## Coincidencia en ejemplos: más PARQUES

Comencemos por explorar cómo funciona la coincidencia formalmente. Aunque un patrón de expresiones regulares puede ser una expresión bastante complicada que contiene caracteres con un significado especial, la expresión regular más simple es solo una cadena de caracteres simples. Supongamos que hay un conjunto de palabras: *PARQUE, CHISPA, ESTACIONAMIENTO, MARCA, QUARKS* . Debes comprobar cuál de ellos contiene la palabra *PARQUE* . Esto es lo que sucede, por ejemplo, cuando realiza una búsqueda Ctrl + F en una página web.

Podemos resolver fácilmente este problema usando el patrón *PARK* . El patrón significa que los símbolos *P, A, R, K* en una palabra deben seguirse de izquierda a derecha. Suponemos que toda la palabra coincide con el patrón si alguna parte (subcadena) de la palabra coincide con él.

![img](https://ucarecdn.com/7020fc68-6ddd-497f-a330-3797afb955d2/)

A continuación se ofrecen algunas explicaciones:

- la palabra *PARQUE* coincide exactamente con nuestro patrón;
- la palabra *S PARK* coincide con nuestro patrón porque tiene una subcadena adecuada;
- la palabra *PARK ING* coincide con nuestro patrón por la misma razón;
- la palabra *M ARK* no coincide con nuestro patrón debido a la letra *M* ;
- la palabra *Q U ARK S* no coincide con nuestro patrón ya que no tiene una pieza adecuada.

En resumen, solo tres palabras coinciden con el `PARK`patrón.



En expresiones regulares, el caso de los caracteres es relevante: *parque* no es lo mismo que *PARK* , es decir, no coinciden.



Además, consideremos otra secuencia de caracteres *PA KR* . No coincide con nuestro patrón ya que dos caracteres tienen un orden incorrecto (inverso).

## El carácter de punto

El carácter de **punto**`.` coincide con cualquier carácter individual, incluidas letras, dígitos, etc., excepto el carácter de nueva línea, a menos que se especifique.

Veamos de nuevo nuestro ejemplo anterior con varias palabras adicionales.

Como recordará, en el ejemplo anterior, dos palabras no coincidían con el patrón debido a un carácter inadecuado. Considérelos y agreguemos también dos palabras adicionales. Aquí está nuestro nuevo patrón `.ARK`con el carácter de punto. Dice: "hay cualquier carácter seguido de *ARK* ".

![img](https://ucarecdn.com/4b680cb0-5ab1-4079-8a71-7eabecefc647/)

¡Hurra, ambas palabras *MARK* y *QUARKS* coinciden con el nuevo patrón! Pero la palabra *WAR M* no concuerda con ella. Piense por un minuto, ¿cómo se puede arreglar esto?

Insinuación



La palabra *ARK* tampoco coincide con nuestro patrón ya que no tiene un carácter en la `.`posición en el patrón, mientras que esto es obligatorio.

### Conclusión

Las expresiones regulares le permiten encontrar cadenas coincidentes según un patrón determinado. Usan caracteres especiales con significados especiales junto con caracteres simples en su interpretación literal:

- el `.`carácter de punto coincide con cualquier carácter único excepto \ n;
- el `?`carácter de signo de interrogación significa "el carácter anterior puede estar ausente de la cadena";
- las expresiones regulares distinguen entre mayúsculas y minúsculas.

Esperamos que empiece a ver que las expresiones regulares proporcionan una herramienta poderosa para procesar cadenas y textos. Con esto, concluimos nuestro tema introductorio sobre ellos. Recuerde que hay muchas más aplicaciones de expresiones regulares que aún no hemos discutido.

| Pregunta                                                     | Respuesta                                                  |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| ¿Cuáles son los "sabores" de las expresiones regulares?      | Diferentes sintaxis                                        |
| ¿Qué metacarácter se usa para coincidir con un solo carácter? | .                                                          |
| ¿Cómo se escribe un comodín que significa "el carácter anterior o nada"? | ?                                                          |
| Tienes un código binario secreto del espacio exterior.       | 4                                                          |
| El signo de interrogación `?`es un carácter especial que ... | coincide con cero o una apariciones del carácter anterior. |
| ¿Qué cuerdas coinciden con el `aa.c?`patrón?                 | "aac", "aacc","aabc"                                       |
| ¿Qué son los comodines?                                      | Metacaracteres especiales                                  |
| Seleccione una o más cadenas que coincidan con la expresión regular dada: 22 dollars | 22 dollars                                                 |

# Teoría: programación informática

 4 minutos0/0 problemas resueltos

Omitir este temaEmpiece a practicar

**0** usuarios resolvieron este tema.**Hace aproximadamente 1 hora**.

En pocas palabras, la programación de computadoras es una forma de hacer que las computadoras realicen diferentes tareas. Es un proceso de escribir un conjunto de instrucciones (también conocido como **código** ) que una máquina puede entender y hacer que la máquina las siga. El objetivo final podría ser resolver una ecuación matemática, automatizar una tarea aburrida o crear una página web, un software, una aplicación móvil o un juego completo.

La programación de computadoras requiere habilidades técnicas y pensamiento creativo. Algunos lo llaman ciencia, otros lo llaman arte.

Para tener una idea completa de lo que es la programación de computadoras, necesitamos resaltar dos puntos en la definición: "hacer que las computadoras *realicen tareas* " y "escribir un conjunto de *instrucciones* que *una máquina pueda entender"* . Primero hablemos de las instrucciones.

## ¿Cuáles son los lenguajes de programación?

Entonces, ¿cómo puedes escribir este conjunto de instrucciones? Piense en una computadora como su amiga extranjera. No entienden ningún idioma excepto el nativo y necesitan descripciones muy simples y claras de cada acción que desea que realicen. ¿Por qué esa última parte? Bueno, um, porque son tus amigos extranjeros que viajan en el tiempo. Mira, ahora esta metáfora me está llevando a lugares. Su computadora es su amigo extranjero que viaja en el tiempo desde, eh, el siglo XII. Por eso no sabe nada de nada.

![img](https://ucarecdn.com/e6544cf1-905b-4988-bdf9-6ecbdc24bfb6/)

Siguiendo esta lógica, no puede simplemente decirle a su computadora que "llame a Steve desde contabilidad". Debe describir cada una de las acciones que incluye este pedido:

1. Coger el teléfono
2. Presione el botón para encender la pantalla
3. Desliza el teléfono para desbloquearlo
4. Abrir contactos
5. Ingrese "Steve de contabilidad" en la búsqueda
6. Abrir contacto de Steve
7. Presione el botón de llamada

¿Y qué fue eso de su lengua materna? Las computadoras no entienden inglés o francés, pero entienden lenguajes de programación como C, Python o Java. Es una simplificación porque las computadoras en realidad no los entienden, solo entienden el código de máquina. Los programadores usan compiladores para traducir el código fuente que escriben al código de la máquina, pero no queremos sobrecargarlo con toda esta información.

Hay más de mil lenguajes informáticos. Los viejos siguen evolucionando y siguen apareciendo nuevos. A continuación, puede ver los lenguajes de programación más populares en 2020 según [PYPL Popularidad del lenguaje de programación](http://pypl.github.io/PYPL.html) .

![img](https://ucarecdn.com/9241261b-bee9-407a-bb7c-703e07d1b572/)

Cada lenguaje de computadora tiene sus propios objetivos y méritos, y algunos lenguajes se adaptan mejor a aplicaciones y tareas específicas. Algunos idiomas son más difíciles, otros menos. Algunos son simples y populares, otros tienen matices y son de nicho. Es importante recordar que, al igual que el inglés, el francés, el ruso o cualquier otro idioma, los lenguajes de programación tienen partes, construcciones y conceptos que se comparten entre todos. Por lo tanto, aprender otro idioma informático será tan difícil (o tan fácil) como aprender uno extranjero. Si comprende la frase "I can write" en inglés, no tendrá muchos problemas para comprender el concepto de "ich kann schreiben" en alemán.

## ¿Qué debo esperar?

Mucho se siente como una rutina, y cuando no es así, es más como golpearse la cabeza contra la pared de ladrillos en medio de un desierto. Sin embargo, muchas personas encuentran una gran alegría en ello. La programación no se trata solo de lenguajes, sintaxis y compiladores, es todo el proceso de pensamiento lógico lo que lo hace tan gratificante. Nunca existe la "mejor" solución al problema. Siempre quieres hacerlo más rápido, mejor y más grande.

La programación le enseña a pensar de manera diferente. Te enseña a pensar en cómo funcionan las cosas y por qué funcionan de esta o aquella forma. El proceso de codificación se siente como un rompecabezas que está constantemente tratando de resolver.

La programación te enseña a tener paciencia. Es una de las cosas más estresantes y agravantes que puede hacer. Mucha gente se frustra y deja de aprender cuando su código no funciona por primera vez. Pero la verdad es que este es un proceso normal. Los programadores con años de experiencia todavía tienen momentos en los que su código no funciona y no tienen idea de por qué. Pero la paciencia y la perseverancia son los rasgos clave que los llevaron a donde están ahora.

La conclusión es que programar es una habilidad. Y al igual que con todas las habilidades, es necesario dedicar algo de tiempo y esfuerzo para ver los resultados. Probablemente no sea fácil, ¡pero definitivamente vale la pena intentarlo! ¡Buena suerte!

## [Programación informática](https://hyperskill.org/learn/step/8739) Aprendizaje desarrollo front-end

¿Qué conjunto de lenguajes es el adecuado para aprender el desarrollo front-end?

HTML, CSS y JavaScript

## [Programación informática](https://hyperskill.org/learn/step/8739) Algoritmo correcto

El desarrollador escribió un algoritmo para un programa que descarga automáticamente el instalador de algún otro programa. Toma el enlace del sitio del instalador y el nombre del sistema como entrada y también comienza la instalación después de la descarga.

Hay varias variantes de este algoritmo a continuación. Cual de ellos es correcto?

1. ir al sitio con el instalador
2. elige el sistema operativo
3. descargar el instalador
4. iniciar la instalación

El programador escribió varias variantes del algoritmo para la computadora, que deberá realizar una búsqueda automática en el navegador:

1. desbloquear la pantalla
2. enciende internet
3. escribir una solicitud
4. haga clic en el botón de búsqueda

Pero el programador se olvidó de un paso importante en este algoritmo. ¿Qué es esta acción?

abre el navegador

¿Cuál es la razón principal por la que tenemos tantos lenguajes de programación?

- Cada lenguaje de programación se adapta mejor a un conjunto particular de problemas

Ordene las acciones del algoritmo para la calculadora.

- abre la calculadora

- escribir datos de entrada

- realizar el cálculo

- mostrar el resultado en la pantalla

Necesitamos lenguajes de programación porque nos pueden ayudar

- escribir algoritmos de acciones comprensibles para la máquina



## Teoría: Introducción al pensamiento computacional



Un lenguaje de programación nos permite explicarle a una computadora cómo ejecutar una solución a un problema particular en el mundo real. Pero primero, un programador tiene que encontrar las soluciones, también usando una habilidad necesaria para cualquier tipo de programación sin importar el idioma. Se llama pensamiento computacional.

## ¿Qué es el pensamiento computacional?

Las computadoras solo pueden manejar instrucciones claras y concisas que estén de acuerdo con las reglas de la lógica formal. Sin embargo, los problemas del mundo real rara vez se recortan con tanta claridad. **El pensamiento computacional** es un conjunto de habilidades mentales que ayudan a ver los problemas como un conjunto de procesos de información complejos que podemos transformar en un conjunto particular de instrucciones para una computadora.

Aborde cada problema que encuentre mientras aprende un lenguaje de programación no solo como una oportunidad para recordar la sintaxis del lenguaje, sino también como una oportunidad para entrenar el pensamiento computacional.

Para hacer eso, puede seguir un algoritmo simple:

1. **Describa el problema**
    ¿Qué se debe hacer exactamente? ¿Qué datos de entrada se le dan y cómo se ve el resultado deseado?
2. **Identifique los detalles importantes necesarios para resolver este problema**
    Antes de pensar en una solución, asegúrese de tener en cuenta todos los aspectos importantes del problema. El diablo está en los detalles y, en el caso de la programación, se esconde en los casos extremos.
3. **Descomponer**
    Divida el problema en pasos pequeños y lógicos hasta que sepa exactamente cómo codificar cada parte del mismo.
4. **Utilice estos pasos para crear un algoritmo que resuelva el problema**
    Conecte las piezas del problema de una manera que produzca el resultado deseado en todos los casos especificados.
5. **Evalúe el proceso**
    Por lo general, un problema tiene al menos algunas soluciones, y es muy útil evaluar su idea para asegurarse de haber elegido una forma que sea lo más eficiente posible.

### Conclusión

Dado que el pensamiento computacional es una habilidad, requiere mucha práctica antes de poder aplicarlo fácilmente. No se desespere si su único pensamiento al analizar un problema es que no tiene idea de cómo lograr los resultados deseados. Usa los algoritmos que describimos y sigue desglosando el problema hasta que veas cómo explicárselo a una computadora con las herramientas del lenguaje de programación que elegiste.

# [Introducción al pensamiento computacional](https://hyperskill.org/learn/step/8742) La receta del pastel de calabaza

Imagina que creaste un robot que te ayudará con las tareas de la casa. Y ahora quiere que hornee un pastel de calabaza, por lo que debe idear un procedimiento. Los pasos se enumeran a continuación, pero ahora debe ponerlos en el orden correcto.

- Lea la lista de ingredientes y compre todos los ingredientes en la tienda.
- Combine los huevos, el puré de calabaza, la leche condensada azucarada y las especias para pastel de calabaza en un tazón grande.
- Coloque la base de pastel en un plato y vierta la mezcla de calabaza en la base.
- Coloque el pastel en una bandeja para hornear y hornee en el horno precalentado durante 30 minutos.
- Apague el horno y coloque el pastel sobre la mesa.

Ponga todos los pasos para resolver un problema de programación en el orden correcto.

- Descripción del problema
- Identificar detalles importantes del problema
- Descomposición
- Creando un algoritmo
- Evaluación de la solución

¿Qué es el pensamiento computacional?

- Una habilidad mental que ayuda a resolver problemas complejos.

Necesita encontrar todos los patrones que se corresponderán con todas las palabras: beast,best ,east.

- b? ea? st
- .?.?.?.?.?
- .....?

## Teoría: componentes del pensamiento computacional

El pensamiento computacional es un conjunto de habilidades que le ayuda a encontrar una solución generalizable a un problema y resolverlo usando una computadora.
Desarrollemos los fundamentos principales de esta habilidad, a saber: **abstracción, descomposición, reconocimiento de patrones** y **evaluación** .

## Descomposición

Los problemas complejos son más fáciles de resolver cuando los dividimos en pasos y subproblemas separados. También hacemos esto todo el tiempo en nuestra vida diaria. Por ejemplo, si su objetivo es hacer una pizza, necesitaría encontrar una receta, comprar todos los ingredientes relevantes, calentar el horno, hacer la masa, picar los ingredientes y finalmente hornear la pizza durante un tiempo adecuado. . Desglosar un problema como ese ayuda a concentrarse en resolver cada subproblema por separado (y tal vez incluso reutilizar las soluciones que se le ocurrieron a otras personas) y evitar sentirse abrumado por los requisitos.

## Extraer y generalizar patrones

Una vez que el problema se descompone, nuestro siguiente paso sería buscar patrones en los subproblemas más pequeños. Un patrón es un conjunto de características en una tarea que se comparte entre más de una instancia del problema. Por ejemplo, si necesita cocinar pizza de pepperoni, necesitará hacer una base plana para pizza. El fondo es un patrón compartido entre todas las pizzas, por lo que puedes generalizar este patrón y si luego deseas hacer Margherita puedes reutilizar toda la información y los pasos que tomaste para preparar la pizza de pepperoni.

El reconocimiento de patrones se basa en los cinco pasos clave:

- Identificar elementos comunes en problemas o sistemas.
- Identificar e interpretar diferencias comunes en problemas o sistemas.
- Identificar elementos individuales dentro de subproblemas.
- Describe los patrones que se han identificado.
- Haga predicciones basadas en patrones identificados.

## Abstracción

La abstracción nos ayuda a generalizar la solución al descubrir un modelo de situación. Nos deshacemos de todos los detalles innecesarios para centrarnos en lo que realmente es importante. Se puede decir que un lenguaje de programación es una abstracción. Utiliza variables para realizar operaciones en lugar de enumerar todos los datos que representan estas variables cada vez.

Es exactamente la abstracción lo que nos ayuda a encontrar una solución generalizable sin escribir un programa separado para cada variación del problema.

Si volvemos a la pizza y tratamos de aplicar la abstracción, diríamos que para que la pizza sea una pizza necesita masa plana, salsa y aderezos.

La forma de la pizza y el hecho de que tenga queso serían detalles innecesarios ya que es posible imaginar una pizza cuadrada sin queso.

Por lo tanto, si abstraemos nuestra pizza como un pastel abierto de masa plana con aderezos y salsa, podríamos escribir un programa para realizar operaciones en todas las pizzas, sin importar su sabor, forma y amabilidad vegana.

## Evaluación

Una vez que haya encontrado una solución a su problema, es útil revisar una lista de verificación de evaluación. A veces, su solución no funcionará y esta lista de verificación también puede ayudarlo a descubrir dónde se ha equivocado.

Asegúrese de que su solución sea:

- Fácil de entender. Por lo general, ese es el caso si el problema se descompone bien.
- Completo. Su solución cubre todos los aspectos del problema. Recuerde, el diablo está en los casos de las esquinas.
- Eficiente. Asegúrese de aprovechar al máximo las herramientas que tiene, en caso de programación, puede considerar el uso de construcciones de sintaxis adecuadas. La velocidad es uno de los marcadores más importantes de la eficiencia de la solución y se vuelve increíblemente importante al escribir código de producción.

Aplicar los conceptos que discutimos es útil para desarrollar un proceso de resolución de problemas más eficiente y estructurado. Después de todo, la capacidad de resolver problemas es lo que convierte en programador a una persona que conoce un lenguaje de programación.

### Conclusión

Entonces, los enfoques que hemos discutido aquí se pueden resumir en dividir un problema en pasos separados, buscar patrones en estos pequeños pasos, hacer un modelo óptimo de un problema y verificar la solución final. Estos conceptos le ayudarán a desarrollar un proceso de resolución de problemas más eficiente y estructurado. Después de todo, la capacidad de resolver problemas es lo que distingue a un programador de una persona que solo conoce un lenguaje de programación.

¿Cuál es el proceso de deshacerse de todos los detalles innecesarios para poder centrarse en lo que realmente importa?

Abstracción

Reorganice los pasos en el orden más apropiado para abordar un problema.

- Divida el problema en etapas y subtareas separadas.
- Encuentra patrones en subtareas más pequeñas.
- Generaliza una solución, deshazte de todos los detalles innecesarios para centrarte en lo que realmente importa.
- Evalúe una solución al problema.

¿Qué criterios puede utilizar para evaluar una solución a un problema?

- La solución es fácil de entender
- La solución es eficaz.
- La solución es completa y cubre todos los aspectos del problema

¿Cuál es el nombre del proceso que ayuda a ver si el problema se resolvió de la manera más eficiente?

- Evaluación

¿Qué logramos abstrayendo?

- Deshazte de todos los detalles sin importancia



# Teoría: ¿Qué es un error?

Un **error de software** es un problema que hace que un programa se bloquee o produzca una salida no válida. Hay muchas razones para los errores de software; los más comunes son los errores humanos en el diseño, la codificación o la comprensión de los requisitos del software.

Un programa generalmente se llama **estable** si no tiene muchos errores obvios. Si el programa tiene una gran cantidad de errores que afectan la funcionalidad y causan resultados incorrectos, se considera **defectuoso** o **inestable** . El usuario no puede interactuar con éxito con dicho software. Es importante encontrar errores **antes de que los** usuarios comiencen a interactuar con su programa.

## Etimología de Bug

Probablemente ya haya escuchado el término "error" y pueda imaginar lo que significa. Aquí hay una pequeña historia sobre esto.

El primer error informático fue descubierto por Grace Murray en la Universidad de Harvard en 1947, mientras trabajaba en la computadora Mark II. Durante la investigación de un problema, se encontró una polilla real entre el contacto de los relés. La polilla se eliminó y se agregó al libro de registro, que ahora se encuentra en el Museo Nacional de Historia Estadounidense de la Institución Smithsonian en Washington, DC.

Por lo tanto, los errores informáticos a menudo se denominan errores. Este término se utiliza para describir cualquier comportamiento incorrecto del programa hasta que se determine la naturaleza específica del error.

![img](https://ucarecdn.com/0bd7a5c3-0cd4-4c6a-86f1-6e2a35ac84af/)



Algunas fuentes de Internet dan una historia diferente de este término. Puede buscarlo en Google si está interesado. Háganos saber si encuentra una historia más confiable para usted.



## ¿Por qué los programas tienen errores?

Los desarrolladores suelen decir que no existe un programa sin errores. Existen algunas razones comunes para los errores en el software:

- problemas de comunicación en el equipo;
- malentendido de los requisitos;
- complejidad del software;
- errores de programación (los programadores, como cualquier otra persona, pueden cometer errores);
- la presión del tiempo;
- uso de tecnologías desconocidas;
- un error en una biblioteca de terceros (sí, eso también sucede).

Durante este curso, encontrará principalmente errores causados por una mala comprensión de los requisitos dados o errores de programación.

## Evitando errores

Es casi imposible evitar todos los errores en un programa grande, pero es posible reducir su número. Aquí te damos cinco pasos que pueden ayudarte a lograrlo tanto en los cursos educativos como en la programación industrial.

1. **Asegúrese de saber qué hacer.** Como programador, debe comprender los requisitos de un programa en el que va a trabajar. Si tiene dudas, siempre puede encontrar ayuda en Internet o entre otros desarrolladores.
2. **Descomponga un programa** en unidades pequeñas que sean fáciles de ver y comprender. Una buena arquitectura reduce la complejidad del software y, como consecuencia, el número de errores.
3. **Escriba código fácil de leer** y siga todos los estándares del idioma. También le permitirá cometer menos errores.
4. **Ejecute el programa** con valores de entrada de límite. No olvide considerar diferentes casos: 0 o un número enorme como valor de entrada, 0 o 1 elemento como secuencia de entrada. Estos casos a menudo revelan errores.
5. **Escriba pruebas automatizadas** que verifiquen el programa en el momento de la compilación.

No discutiremos las pruebas automatizadas en este tema, pero volveremos a eso más adelante. En este momento, puede simplemente crear un conjunto de valores de entrada y ejecutar el programa manualmente (como se describió en el paso 4).

## Depuración

Suponga que sabe que su programa no funciona correctamente para algunos valores de entrada. Para corregir este error, debe encontrarlo en el código y luego realizar algunos cambios.

Para localizar un lugar con buggy, puede:

- lea el código e intente comprender qué hace con los valores de entrada;
- inicie el depurador y vea los valores actuales de las variables y el flujo de control del programa;
- imprima el estado actual del programa en partes críticas del código (registro) y luego analícelo.

La combinación de los enfoques anteriores le permitirá encontrar la mayoría de los errores en su programa.

### Conclusión

Resumamos este tema. Un error es el comportamiento incorrecto de un programa. Sin embargo, existen formas de reducir la cantidad de errores. Por ejemplo, comprender los requisitos del programa, seguir los estándares del lenguaje, construir una arquitectura clara del programa, verificar el programa con valores límite y usar pruebas automatizadas.

Si aún tiene un error, en primer lugar, debe ubicarlo en el código. Para eso, puede usar un depurador o un registro, o intentar comprender qué hace el código con los valores de entrada leyéndolo. Utilice estos consejos y, lo más probable, evitará escribir programas con errores y perder tiempo depurándolos.

¿Cómo se puede describir un programa si tiene una gran cantidad de errores que afectan la funcionalidad y provocan resultados incorrectos?

- inestable
- incorrecto

Un error es:

- un problema que hace que un programa se bloquee o produzca una salida no válida

Se encomendó a un equipo de desarrollo que escribiera código que procesara los datos de entrada en el sitio. Escribieron un programa que puede leer contraseñas en forma de números, nombres e inicios de sesión.

Pero obtuvieron un error al probar el programa. Las contraseñas, además de los números, también deben contener letras. Ya sabes qué razones conducen a errores. Entonces, ¿cuál de ellos contribuyó al hecho de que los desarrolladores fracasaron?

- malentendido de los requisitos, no estaban claros

Seleccione las razones esenciales de los errores de software.

- errores de programación
- problema con la comunicación en el equipo (cuando no está trabajando solo)
- malentendido de los requisitos

¿Qué se puede hacer para localizar un lugar con buggy?

- analizar el código
- imprimir el estado actual del programa
- iniciar el depurador

¿Cuál de las siguientes recomendaciones puede reducir la cantidad de errores en su programa?

- ejecutar el programa con valores de entrada de límite
- entender lo que necesita para desarrollar

Imagina que escribiste el código y no funciona correctamente debido a errores. ¿Qué puedes hacer para arreglar el código? Elija varias acciones posibles a continuación.

- escribir pruebas automatizadas
- crear un conjunto de valores de entrada y ejecutar el programa manualmente

# Teoría: Introducción a la programación orientada a objetos

## Fundamentos

**La programación orientada a objetos (POO)** es un paradigma de programación basado en el concepto de **objetos** que interactúan entre sí para realizar las funciones del programa. Cada objeto puede caracterizarse por un estado y un comportamiento. El estado actual de un objeto está representado por sus **campos** y el comportamiento de un objeto está representado por sus **métodos** .

## Principios básicos de la programación orientada a objetos

Hay cuatro principios básicos de la programación orientada a objetos. Son **encapsulación, abstracción, herencia** y **polimorfismo.**

- **La encapsulación** asegura la agrupación (= encapsulación) de datos y los métodos que operan en esos datos en una sola unidad. También se refiere a la capacidad de un objeto para ocultar la estructura interna de sus propiedades y métodos.
- **La abstracción de datos** significa que los objetos deben proporcionar la versión abstracta y simplificada de sus implementaciones. Los detalles de su trabajo interno generalmente no son necesarios para el usuario, por lo que no es necesario representarlos. La abstracción también significa que solo se presentarán las características más relevantes del objeto.
- **La herencia** es un mecanismo para definir las relaciones padre-hijo entre clases. A menudo, los objetos son muy similares, por lo que la herencia permite a los programadores reutilizar la lógica común y al mismo tiempo introducir conceptos únicos en las clases.
- **Polimorfismo** significa literalmente "tener muchas formas" y es un concepto relacionado con la herencia. Permite a los programadores definir diferentes implementaciones para el mismo método. Por lo tanto, el nombre (o la interfaz) sigue siendo el mismo, pero las acciones realizadas pueden diferir. Por ejemplo, imagine un sitio web que publica tres tipos principales de texto: noticias, anuncios y artículos. Son algo similares en el sentido de que todos tienen un título, algo de texto y una fecha. En otros aspectos, son diferentes: los artículos tienen autores, los boletines de noticias tienen fuentes y los anuncios tienen una fecha a partir de la cual se vuelven irrelevantes. Es conveniente escribir una clase abstracta con información general para todas las publicaciones para evitar copiarla cada vez y almacenar lo que es diferente en las clases derivadas apropiadas.

Estos son los conceptos clave de OOP. Cada lenguaje orientado a objetos implementa estos principios a su manera, pero la esencia permanece igual de un lenguaje a otro.

## Objetos

La noción clave de POO es, naturalmente, un **objeto.** Hay muchos objetos del mundo real a tu alrededor: mascotas, edificios, automóviles, computadoras, aviones, lo que sea. Incluso un programa de computadora puede considerarse un objeto.

Es posible identificar algunas características importantes de los objetos del mundo real. Por ejemplo, para un edificio, podemos considerar el número de pisos, el año de construcción y el área total. Otro ejemplo es un avión que puede acomodar a un cierto número de pasajeros y trasladarlo de una ciudad a otra. Estas características constituyen los **atributos** y **métodos** del objeto . Los atributos caracterizan estados o datos de un objeto y los métodos caracterizan su comportamiento.

En OOP, todo puede verse como un objeto; una clase, por ejemplo, también es un objeto. Los programas se componen de diferentes objetos que interactúan entre sí. El estado y el comportamiento del objeto suelen combinarse, pero no siempre es así. A veces vemos objetos sin estado ni métodos. Esto, por supuesto, depende del propósito del programa y la naturaleza del objeto.

Por ejemplo, existe una interfaz. No es una interfaz de usuario, sino una clase que solo sirve para ser heredada para garantizar una interfaz a sus clases descendientes. Es una clase de apátridas. Las estructuras existen en C ++ por razones históricas. Ahora, una estructura también es una clase, pero una vez una estructura solo tenía propiedades y no tenía ningún método, un tipo para almacenar datos y nada más. Estos son casos especiales y, a veces, son útiles.

## Clases

A menudo, muchos objetos individuales tienen características similares. Podemos decir que estos objetos pertenecen al mismo **tipo** o **clase** .

Una clase es otra noción importante de POO. Una clase describe una estructura común de objetos similares: sus campos y métodos. Puede considerarse una plantilla o un plano para objetos similares. Un objeto es una **instancia** individual de una clase.

De acuerdo con el principio de encapsulación mencionado anteriormente, cualquier clase debe considerarse como una caja negra, es decir, el usuario de la clase debe ver y usar solo la parte de interfaz de la clase, es decir, la lista de propiedades y métodos declarados, y No conviene ahondar en la implementación interna.

Veamos algunos ejemplos a continuación.

**Ejemplo 1. La clase de edificio**



**![img](https://ucarecdn.com/b0bcc13c-0f35-40f9-97bc-e78b56f5a556/)**



**Un edificio abstracto para describir edificios como un tipo de objeto (clase)**

Cada edificio tiene los mismos atributos:

- Número de pisos (un número entero);
- Área (un número de coma flotante, metros cuadrados);
- Año de construcción (un número entero).

Cada objeto del tipo de edificio tiene los mismos atributos pero valores diferentes.

Por ejemplo:

- Edificio 1: número de pisos = 4, área = 2400.16, año de construcción = 1966;
- Edificio 2: número de pisos = 6, área = 3200.54, año de construcción = 2001.

Es bastante difícil determinar el comportamiento de un edificio, pero este ejemplo demuestra los atributos bastante bien.

**Ejemplo 2. La clase de avión**

A diferencia de un edificio, es fácil definir el comportamiento de un avión: puede volar y trasladarte entre dos puntos del planeta.



**![img](https://ucarecdn.com/e2dd006a-b80c-4761-98c9-5c76f563fec8/)**

**Un plano abstracto para describir todos los planos como un tipo de objeto (clase)**

Cada plano tiene los siguientes atributos:

- Nombre (una cadena, por ejemplo, "Airbus A320" o "Boeing 777");
- Capacidad de pasajeros (un número entero);
- Velocidad estándar (un número entero);
- Coordenadas actuales (son necesarias para navegar).

Además, tiene un comportamiento (un método): trasladar pasajeros de un punto geográfico a otro. Este comportamiento cambia el estado de un avión, es decir, sus coordenadas actuales.

### Conclusión

Para decirlo de manera concisa, debe recordar lo siguiente:

- Un programa orientado a objetos consta de un conjunto de objetos que interactúan.
- Según el principio de encapsulación, el usuario no puede acceder a la implementación interna del objeto.
- Un objeto puede tener características: campos y métodos.
- Un objeto es una instancia de una clase (tipo);
- Una clase es un concepto más abstracto que un objeto individual; puede considerarse una plantilla o plano que describe la estructura común de un conjunto de objetos similares.

| POO    | Significado                           |
| ------ | ------------------------------------- |
| Clase  | Tipo de objeto                        |
| Campo  | Estado de un objeto                   |
| Método | Comportamiento de un objeto           |
| Objeto | Una instancia individual de una clase |



Una clase es una plantilla (o plano) para crear un (an) ...

- objeto

El comportamiento de un objeto está representado por su 

- método

El estado de un objeto se almacena en su

- campos (o atributos)

Un programa orientado a objetos consta de un conjunto de

- objetos que interactúan

La programación orientada a objetos se basa en 4 principios. Encuentre el que se explica **incorrectamente:**

- La herencia consiste en nombrar las variables de la manera tradicional.

Normalmente, los objetos interactúan entre sí a través de 

- métodos

# Teoría: inmutabilidad

En filosofía, hay un experimento mental llamado **"Barco de Teseo"** . Es uno de los conceptos más antiguos de la filosofía occidental y es así.

El famoso barco del héroe Teseo se ha conservado como pieza de museo en un puerto. A lo largo de los años, las piezas de madera se han podrido y han sido reemplazadas. Cien años después, todas las partes de madera del barco han sido reemplazadas. La pregunta es: ¿sigue siendo el mismo barco?

![img](https://ucarecdn.com/3b2ef8c8-ef58-47b4-84a9-a37eb08dcc25/)

Hay muchas formas de responder a esta pregunta y puedes consultarlas en [Wikipedia](http://en.wikipedia.org/wiki/Ship_of_Theseus) . Lo que nos interesa es que esta cuestión de la identidad también se pueda aplicar a la programación. Uno de los conceptos más importantes de la programación, el que está directamente relacionado con el cambio y la identidad, es el concepto de **(im) mutabilidad.**

En este tema, leerá sobre la idea general de inmutabilidad y, en los siguientes temas, explorará los medios para garantizar la inmutabilidad en el lenguaje de programación que ha elegido estudiar.

## Mutabilidad e inmutabilidad

**La mutabilidad** significa literalmente "la cualidad de ser cambiante" y, en programación, se refiere a la idea de cambiar el estado del objeto después de que ha sido creado.

En esta línea, podemos distinguir entre objetos **mutables** e **inmutables** . En pocas palabras, los objetos mutables se pueden alterar una vez que se han creado y los inmutables no. Esta es la diferencia clave entre objetos mutables e inmutables.

¿Qué significa esto en la práctica? Los objetos inmutables siempre representan el mismo valor: si desea tener un valor diferente, debe crear un objeto completamente nuevo o reasignar el valor del existente. Con los objetos mutables, las cosas son mucho más fáciles y podemos cambiar los valores que contienen sin reasignar la variable o crear un nuevo objeto.

Volviendo al barco de Teseo, si lo consideráramos un objeto inmutable, entonces la respuesta a la cuestión de la identidad sería no. Una vez que cambia algo, tiene un objeto diferente. En otras palabras, ¡el barco de Teseo ya no es el barco de Teseo aunque tenga el mismo nombre!

Alternativamente, si consideramos la nave como un objeto mutable, entonces, sí, sigue siendo la misma nave. Los cambios que hicimos no afectaron su identidad.

Dependiendo del lenguaje de programación que esté utilizando, los diferentes tipos de objetos pueden ser inmutables. Por ejemplo, las cadenas son inmutables en Python y Java, pero Java también tiene otro tipo de cadenas que es mutable. En Ruby y PHP, las cadenas son mutables. Al escribir un programa en su idioma favorito, debe tener en cuenta qué objetos son mutables y cuáles son inmutables en ese idioma en particular.

## Objetos personalizados e inmutabilidad

En general, los objetos de clases personalizadas son mutables. Sin embargo, hay casos en los que querríamos hacerlos inmutables: los objetos inmutables son seguros para subprocesos, más fáciles de probar y pueden ser más seguros.



Los objetos inmutables se pueden compartir entre diferentes subprocesos sin protección adicional. El estado de los objetos mutables es difícil de seguir siempre que puedan ser modificados por cualquiera de los subprocesos de trabajo.



En el contexto de los objetos personalizados, también podemos hablar de **inmutabilidad débil** e **inmutabilidad fuerte.** La inmutabilidad débil es cuando algunos campos de un objeto son inmutables y otros son mutables. La inmutabilidad fuerte es cuando todos los campos de un objeto son inmutables.

Las instrucciones específicas sobre cómo hacer que una clase personalizada sea inmutable dependen del idioma, pero podemos dar pautas generales. Básicamente, debe prohibir cambiar el valor del campo una vez que se ha creado o prohibir reasignar el valor. Esto se puede hacer, por ejemplo, haciendo que la variable sea de solo lectura o una constante. Otra opción es modificar los métodos que establecen valores de atributo para que generen excepciones. También puede trabajar con modificadores de acceso: haga que los campos sean inalcanzables desde fuera de la clase.

## Resumen

En resumen, la diferencia entre objetos mutables e inmutables radica en el hecho de que los objetos mutables pueden cambiar su estado después de la creación y los objetos inmutables no. Los lenguajes tienen su propia división en objetos mutables e inmutables. Las clases personalizadas suelen ser mutables, pero pueden volverse inmutables utilizando herramientas y técnicas específicas del lenguaje si es necesario.

¿En qué situaciones es mejor utilizar un **objeto inmutable?**

- Cuando desee incorporar múltiples subprocesos en su programa.

- Cuando desee que el valor del objeto permanezca igual todo el tiempo.

pongamos que tenemos un objeto personalizado `MyObject`. Tiene dos campos: `field1`es mutable y `field2`es inmutable. No se imponen restricciones adicionales en estos campos: podemos acceder a ellos desde fuera de la clase o reasignar las variables de campo.

Seleccione todas las declaraciones correctas sobre `MyObject`.

- **MyObject** es un objeto débilmente inmutable.
- **field2** no puede tener un valor diferente a menos que creemos un nuevo objeto

¿Cuál es la diferencia clave entre objetos **mutables** e **inmutables** ?

- Los objetos mutables se pueden cambiar después de la creación y los inmutables no.

Supongamos que hemos creado un objeto personalizado que representa la nave de Teseo. Teniendo en cuenta que algunas partes de la nave necesitan ser reemplazadas de vez en cuando, ¿deberíamos hacer que este objeto sea **mutable** o **inmutable?**

Escriba la respuesta (la palabra **mutable** o **inmutable) a** continuación.

- Mutable

Empareje los conceptos en mutabilidad con sus definiciones.

| concepto                     | definicion                                                   |
| ---------------------------- | ------------------------------------------------------------ |
| Objeto débilmente inmutable  | Algunos campos del objeto son inmutables y otros son mutables |
| Objeto fuertemente inmutable | Todos los campos del objeto son inmutables.                  |
| Objeto mutable               | Todos los campos del objeto son mutables                     |

Kate está escribiendo un programa que procesa texto. Se le da una serie de cadenas, que procesa una por una: convierte todos los caracteres en minúsculas, elimina la puntuación, etc. Mientras realiza el procesamiento, Kate quiere almacenar todas estas cadenas procesadas en un objeto de colección. ¿Qué tipo de colección debería usar: **mutable** o **inmutable?**

Tenga en cuenta que Kate no sabe cuántas cuerdas se le darán por adelantado. Es posible que también desee editar la colección después: eliminar cadenas idénticas o seguir procesando cadenas particulares.

En el campo de respuesta a continuación, escriba qué tipo de colección se adapta mejor a la tarea de Kate: **mutable** o **inmutable.**

- Mutable

Imagínese, tiene una caja de objetos llamada `my_favorite_box`. El tipo de artículos en la caja no está predeterminado y por el momento se trata de una caja de gatitos.

El objeto `my_favorite_box`se considera **inmutable** (pero se **permite la** reasignación de variables ).

¿Qué puedes hacer con el objeto `my_favorite_box`? Elija todas las que correspondan.

- El estado interno de un objeto inmutable sigue siendo el mismo. Esto significa que no se puede sumar ni restar nada. Por ejemplo, String st = "New string"; (no se puede agregar ni restar de un objeto inmutable). :)
- Consiga una caja de cachorros y diga que ahora esta caja es `my_favorite_box`
- Mira los gatitos que hay en la caja.

# Theory: Introduction to Python

La informática existe desde hace un tiempo y los lenguajes de programación son una de sus principales herramientas. Estos están diseñados para ayudarnos a implementar software para ejecutar en una computadora. Al igual que los lenguajes naturales para las personas, sirven como herramienta de comunicación, solo entre personas y máquinas. En este tema, aprenderemos sobre el que ha ganado popularidad exponencialmente entre los desarrolladores recientemente. ¡Mira, esta es una introducción a Python!

## ¿Qué es Python?

**Python** es un lenguaje de programación moderno de propósito general desarrollado inicialmente por un programador holandés llamado Guido van Rossum a fines de la década de 1980. El nombre proviene del popular programa de Monty Python, no de la serpiente, como podría pensar. Este lenguaje tiene una sintaxis limpia, uniforme y legible y está diseñado para que sea fácil de aprender y usar en la práctica.

Hoy en día, Python es uno de los lenguajes de programación más populares en todo el mundo, según el índice [TIOBE](https://www.tiobe.com/tiobe-index/) . ¡El número de programadores que lo utilizan crece día a día! El lenguaje tiene una gran comunidad de desarrolladores en todo el mundo. Si tiene un problema, siempre puede pedir ayuda a otros programadores o encontrar una respuesta adecuada en un sitio como [Stack Overflow](https://stackoverflow.com/questions/tagged/python) .

¡Desarrollar software con Python es fácil y divertido!

![img](https://ucarecdn.com/33368eeb-d6f0-4356-90d4-c5aab4126fbc/)



**Logotipo de Python**

Python tiene una amplia gama de posibles aplicaciones, especialmente en:

- Desarrollo web;
- Ciencia de datos (incluido el aprendizaje automático);
- Scripting (automatización de tareas, como procesamiento de texto o simulación de acciones típicas del usuario).

También se utiliza en el **desarrollo de escritorio** , aunque con menos frecuencia.

## Python en la ciencia de datos

La gran popularidad de Python en los últimos años se debe principalmente a su uso en la ciencia de datos. ¿Qué lo hace mejor que otros idiomas para este propósito? Bueno, hay varias razones:

- Su sintaxis simple permite que las personas que no tienen experiencia en programación lo utilicen para el procesamiento de datos y el entrenamiento de modelos sin perder mucho tiempo aprendiendo un nuevo idioma.
- Python admite una gran cantidad de bibliotecas de terceros para aprendizaje automático, redes neuronales, estadísticas y cálculos numéricos, lo que facilita mucho su trabajo.
- Con Python, es posible recopilar, limpiar y explorar datos, así como entrenar modelos y visualizar los resultados, ¡todo en una sola configuración!
- La comunidad de desarrolladores de Python ML es muy grande, por lo que siempre puede encontrar soporte para sus tareas.

Como puede ver, Python tiene mucho que ofrecer para los entusiastas de la ciencia de datos.

## Una breve historia de Python

Como otros lenguajes de programación, Python ha pasado por varias versiones. Python 1.0 fue lanzado en 1994 y estableció los principios básicos del lenguaje con énfasis en la simplicidad.

Python 2.0 fue lanzado en 2000. Esta versión se ha vuelto muy popular entre los programadores. Todavía se utilizan diferentes subversiones 2.x (2.6, 2.7) en varios proyectos y bibliotecas. El símbolo **x** en 2.x significa cualquier subversión de Python 2.

Python 3.0 fue la siguiente versión principal lanzada en 2008. Rompió la compatibilidad con sus predecesores para eliminar el desorden histórico del lenguaje y hacer que Python sea más legible y consistente.

Hoy en día, se usan comúnmente dos versiones de Python similares pero incompatibles.



A lo largo de este curso, trabajaremos con Python 3.x.



## Primer ejemplo de programa

Aquí hay una sola línea de código Python que se imprime `Learn Python to be great!`.

```python
print("Learn Python to be great!")
```

Por ahora, no es necesario que comprenda cómo funciona este código: simplemente aprecie su hermosa sintaxis que no está muy lejos del inglés normal.

## Resumen

Resumamos lo que hemos aprendido en este tema:

- qué es Python;
- sus aplicaciones;
- las razones por las que Python es tan popular en el campo de la ciencia de datos;
- la historia del idioma;
- cómo escribir código simple en Python.

Ahora, cuando sepa las cosas más básicas sobre Python, ¡estará listo para continuar su viaje hacia él!

Es probable que conocer la compatibilidad de las versiones de Python le ayude en el futuro. Si lo conoce, puede leer fácilmente el código anterior y corregirlo, para que se ejecute sin errores en las versiones más recientes de Python.

¿Cuándo se volvió Python incompatible con sus versiones anteriores? Ingrese **el número** de la versión que rompió la compatibilidad con versiones anteriores. No es necesario utilizar la declaración impresa o las comillas, solo escriba el número.

- 3.0

Recientemente, Python ha ganado popularidad en el área de la ciencia de datos. ¿Por qué sucedió?

- Python tiene muchas herramientas para recopilar y limpiar datos.
- Python tiene herramientas de terceros para aprendizaje automático y redes neuronales.
- La sintaxis simple de Python acelera el proceso de escritura de código.
- Python tiene herramientas para cálculos numéricos y estadísticas.
- Puede visualizar fácilmente sus resultados usando Python.
- Todas las opciones anteriores son correctas.

# Teoría: PEP 8



¿Cómo escribir código limpio y fácil de leer? Esa es la pregunta con la que se tropieza al pasar de programas simples de una sola línea a programas más complicados. Al principio, puede parecer poco importante, pero en la vida real, la programación es un proceso que involucra a muchas personas que trabajan juntas, por lo que pasas más tiempo leyendo código que escribiéndolo.

Aunque Python suele ser más legible que otros lenguajes de programación debido a su sintaxis minimalista, la sintaxis en sí misma no es suficiente. Es la forma en que escribe el código lo que afecta la legibilidad general. Es por eso que debe seguir las convenciones comunes con respecto al estilo de programación, para que otros programadores puedan leer su código fácilmente.

Puede preguntar, ¿de dónde provienen estas convenciones? Existe un documento que se llama [PEP 8](https://www.python.org/dev/peps/pep-0008/) . La idea clave es usar el mismo estilo de código para todos los proyectos de Python como si fueran escritos por el mismo programador. Este documento garantiza que incluso un principiante comprenderá fácilmente el código escrito por cualquier otro desarrollador.

## PEP

Antes de continuar, hablemos de PEP por un momento. PEP son las siglas de **Python Enhancement Proposal** . Hay diferentes tipos de PEP y el más útil para los principiantes es el PEP informativo. Los PEP de este tipo suelen describir pautas o convenciones comúnmente aceptadas sobre el idioma, por lo que pueden ser muy útiles. Además de PEP 8, que es una guía de estilo oficial, otro gran PEP a tener en cuenta es [el Zen de Python](https://www.python.org/dev/peps/pep-0020/) .

Como sabemos qué es PEP 8, leamos un poco.

## La longitud de una línea

No utilice más de 79 caracteres en una línea de código. Las líneas más cortas se ven mejor en los editores de código. Durante este curso, aprenderemos varias formas de lograrlo.

## Evite espacios extra

A veces, puede agregar algunos espacios incluso si realmente no los necesita. Esto reducirá la legibilidad de su código.

- **Evite espacios adicionales entre paréntesis.**

Bien:

```python
print('Hello!')
```

Malo:

```python
print( 'Hello!' )
```

- **Evite un espacio extra antes de un paréntesis abierto.**

Bien:

```python
print('some text')
```

Malo:

```python
print ('some text')
```

## Citas

Como ya se mencionó, puede usar comillas simples o dobles para definir cadenas. Por favor, elija el que más le guste y utilícelo constantemente en su código. La única recomendación en PEP 8 es que si una cadena contiene comillas simples o dobles, debe usar la otra para evitar barras diagonales inversas.

Bien:

```language-python
print("It's a good string!")
```

Malo y más difícil de leer:

```language-python
print('It\'s a bad string!')
```

La barra invertida en este caso es un carácter de escape que se utiliza para indicar que la siguiente comilla simple no es el final de la cadena; lo aprenderá con más detalle más adelante. Por ahora, tenga en cuenta que el primer ejemplo es más fácil de leer.

## ¿Que sigue?

Más adelante, aprenderá muchas cosas sobre Python y se convertirá en un programador más hábil, pero seguir el estilo del código siempre será importante. Sin embargo, no se preocupe: no es necesario que aprenda todas las convenciones a la vez; simplemente ábrelos de vez en cuando después de aprender algo nuevo. También daremos partes de estas convenciones en este curso.

## Resumen

Así, en este tema, descubrimos qué es PEP 8, dónde encontrarlo y cómo usarlo. Repasemos también brevemente los puntos principales que discutimos:

- la longitud de una línea de código no debe exceder los 79 caracteres;
- deben evitarse los espacios adicionales;
- las comillas deben usarse de manera consistente y / o para evitar barras invertidas.



# Theory: Comments

Sometimes you need to explain what some particular parts of your code are for. Lucky you, since Python gives you an opportunity to fulfill your needs. You can leave special notes called **comments**. They are especially useful for beginners. Throughout this course, we will often use comments to explain our examples.

## What is a comment?

Python comments start with a **hash #**. Everything after the hash mark and up to the end of the line is regarded as a comment and will be **ignored** when running the code.

```python
print("This will run.")  # This won't run
```

In the example above, you can see what PEP 8 calls an **inline** comment because it's written on the same line as the code.

A comment can also refer to the block of code that follows it:

```python
# Outputs three numbers
print("1")
print("2")
print("3")
```

We intend to use such comments primarily for learning purposes. Now, it's time to find out how to comment code properly.

## Formatting comments

Although it is pretty easy to write a comment, let's discuss how to do this in accordance with best practices.

To begin with, after a hash mark there should be **one space** and, in inline comments, there should be **two spaces** between the end of the code and the hash mark. Putting more than two spaces between the end of the code and the hash mark is also acceptable but most commonly there are exactly two spaces.

```python
print("Learning Python is fun!")  # This is proper comment formatting
print("PEP-8 is important!")#This is a very bad example
```

Indent your comment to the same level as the statement it explains. E.g. the following example is wrong:

```python
    # this comment is at the wrong place
print("This is a statement to print.")
```

A comment is not a Python command: it should not be too long. Following PEP-8, the comment length should be limited to 72 characters. It's better to split a long comment into several lines: you can do it by adding a hash mark at the beginning of each new line:

```python
# Imagine that this is an example of a really long comment
# that we need to spread over three lines, so we continue
# to write it even here.
print("The long comment above explains this line of code.")
```

Comments that span multiple lines are called **multi-line** or **block** comments. In Python, there is no special way to indicate them.



You may come across multi-line comments enclosed in triple quotes `"""..."""`, still, we recommend that you use several hash marks for this purpose. Thus, your code will comply with the [official style guide](https://www.python.org/dev/peps/pep-0008/#block-comments). Triple quotes are reserved for **documentation strings**, or **docstrings** for short. They are also informative, but their use is limited to functions, methods and several other cases.



We hope our comments will help you understand our code examples better!

## Summary

In this topic, we learned what comments are and what they're used for. The main points are:

- Comments are used to explain what particular parts of your code are for;
- Comments start with a **hash #**;
- Comments are ignored during the execution of the code;
- Comments might be above a piece of code, inline, or form a block.

There are also certain comment formatting rules you should follow according to PEP 8:

- There should be **one space** after a hash mark; in addition, in inline comments, there should be **two spaces** between the end of the code and the hash mark.
- The comment length should be limited to 72 characters; you can split a long comment into several lines forming a block.
- Indent your comment to the same level as the statement it explains.

# Theory: Basic data types

Every *data object* (a variable or a constant) has a type that describes how to keep it in memory, which operations can be applied to this object and how to compute them.

A real-world analogy of types may be biological species or any other abstract attribute shared among specific objects. All the dogs you've seen have type *dog*, but each of them is an individual object. Thinking about a *dog* as a type you can assume some operations available, for example, a dog can bark.

In this topic, we will consider only a few of the simplest data types that are commonly used in programming practice.

## Strings

Whenever you want to work with some kind of textual information in your program, you'll have to work with **strings**. The string type is called `str`. Strings are extremely common and useful in Python. String literals may be delimited using either single or double quotes.

- Examples of strings in double quotes:

```python
print("")               # empty string
print("string")         # one word
print("Hello, world!")  # a sentence
```

- Examples of strings in single quotes:

```python
print('a')                   # single character
print('1234')                # a sequence of digits
print('Bonjour, le monde!')  # a sentence
```

In a real program, a string can represent an email of a person or an organization.

```python
print('hello@hyperskill.org')  # printing an email
```

As you can see, strings are very easy to use!

## Numerical types

Numbers are the most important thing for any programmer. There is hardly any serious program you can write without using numbers, so let's discuss some basic **numerical types**:

- `int` **(signed integers)**. Called integers or ints, they are whole numbers (positive, negative, or zero), having no decimal point;
- `float` **(floating-point numbers)**. Called floats, they represent real numbers and have a decimal point.

You can start working with a number by just printing it out.

```python
print(11)    # prints 11
print(11.0)  # prints 11.0
```

Even though `11` and `11.0` are the same number, the former is an integer, and the latter is a float. The simplest way to distinguish them is that floats have a **decimal point** and integers don't. Pay attention!

You can also use negative numbers as well as zeroes:

```python
print(0)      # prints 0
print(-5)     # prints -5
print(-1.03)  # prints -1.03
```

Integer numbers can be used to count things in the real world while floating-point numbers are a good choice for statistical and scientific calculations.

## Printing types

We also have a way to clearly demonstrate types of different objects using the `type()` function which is a part of Python.

```python
print(type('hello'))  # <class 'str'>
print(type("world"))  # <class 'str'>

print(type(100))      # <class 'int'>
print(type(-50))      # <class 'int'>

print(type(3.14))     # <class 'float'>
print(type(-0.5))     # <class 'float'>
```

As you can see from the examples above, the `type()` function indicates the data type of a passed value after the word *class*.

## Summary

We hope that now you have some intuition about the concept of data types. You should remember the simplest types called `str`, `int` and `float` and how to write their literals. In the following topics, we will learn specific features of each of these types. If you need to know the type of an object, just print it using the `type()` function.



# Theory: Integer arithmetic

In real life, we often perform arithmetic operations. They help us to calculate the change from a purchase, determine the area of a room, count the number of people in a line, and so on. The same operations are used in programs.

## Basic operations

Python supports basic arithmetic operations:

- addition `+`
- subtraction `-`
- multiplication `*`
- division `/`
- integer division `//`

The examples below show how it works for numbers.

```python
print(10 + 10)   # 20
print(100 - 10)  # 90
print(10 * 10)   # 100
print(77 / 10)   # 7.7
print(77 // 10)  # 7
```

There is a difference between division `/` and integer division `//`. The first produces a floating-point number (like `7.7`), while the second one produces an integer value (like `7`) ignoring the decimal part.

Python raises an error if you try to divide by zero.

```no-highlight
ZeroDivisionError: division by zero
```

## Writing complex expressions

Arithmetic operations can be combined to write more complex expressions:

```python
print(2 + 2 * 2)  # 6
```

The calculation order coincides with the rules of arithmetic operations. Multiplication has a higher priority level than addition and subtraction, so the operation `2 * 2` is calculated first.

To specify an order of execution, you can use **parentheses,** as in the following:

```python
print((2 + 2) * 2)  # 8
```

Like in arithmetic, parentheses can be nested inside each other. You can also use them for clarity.

The minus operator has a unary form that negates the value or expression. A positive number becomes negative, and a negative number becomes positive.

```python
print(-10)  # -10
print(-(100 + 200))  # -300
print(-(-20))  # 20
```

## Other operations

**The remainder** **of a division.** Python modulo operator `%` is used to get the remainder of a division. It may come in handy when you want to check if a number is even. Applied to `2`, it returns `1` for odd numbers and `0` for the even ones.

```python
print(7 % 2)  # 1, because 7 is an odd number
print(8 % 2)  # 0, because 8 is an even number
```

Here are some more examples:

```python
# Divide the number by itself
print(4 % 4)     # 0
# At least one number is a float
print(11 % 6.0)  # 5.0
# The first number is less than the divisor
print(55 % 77)   # 55
# With negative numbers, it preserves the divisor sign
print(-11 % 5)    # 4
print(11 % -5)    # -4
```



Taking the remainder of the division by `0` also leads to `ZeroDivisionError`.



The behavior of the mod function in Python might seem unexpected at first glance. While `11 % 5 = 1` and `-11 % -5 = -1` when both numbers on the left are of the same sign, `11 % -5 = -4` and `-11 % 5 = 4` if we have one negative number. The thing is, in Python, the remainder always has the same sign as the divisor.

In the first case, `11 % -5 = -4`, as the remainder should be negative, we need to compare 15 and 11, not 10 and 11: `11 = (-5) * (-3) + (-4)`. In the second case, `-11 % 5 = 4`, the remainder is supposed to be positive: `-11 = 5 * (-3) + 4`.

**Exponentiation.** Here is a way to raise a number to a power:

```python
print(10 ** 2)  # 100
```

This operation has a higher priority over multiplication.

## Operation priority

To sum up, there is a list of priorities for all considered operations:

1. parentheses
2. power
3. unary minus
4. multiplication, division, and remainder
5. addition and subtraction

As mentioned above, the unary minus changes the sign of its argument.

Sometimes operations have the same priority:

```python
print(10 / 5 / 2)  # 1.0
print(8 / 2 * 5)   # 20.0
```

The expressions above may seem ambiguous to you, since they have alternative solutions depending on the operation order: either `1.0` or `4.0` in the first example, and either `20.0` or `0.8` in the second one. In such cases, Python follows a left-to-right operation convention from mathematics. It's a good thing to know, so try to keep that in mind, too!

## PEP time!

There are a few things to mention about the use of binary operators (that is, the operators that influence both operands). As you know, readability does matter in Python. So first, remember to surround a binary operator with a single space on both sides:

```python
number=30+12      # No!

number = 30 + 12  # It's better this way
```

Also, sometimes people use the break **after** binary operators. But this can hurt readability in two ways:

- the operators are not in one column,
- each operator has moved away from its operand and onto the previous line:

```python
# No: operators sit far away from their operands
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
```

Mathematicians and their publishers follow the opposite convention in order to solve the readability problem. Donald Knuth explains this in his *Computers and Typesetting* series: "Although formulas within a paragraph always break after binary operations and relations, displayed formulas always break before binary operations". Following this tradition makes the code more readable:

```python
# Yes: easy to match operators with operands
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

In Python code, it is **permissible** to break before or after a binary operator, as long as the convention is consistent locally. For new code, **Knuth's style** is suggested, according to PEP 8.

## Summary

Alright, now let's quickly overview what we've learned in this topic:

- what basic arithmetic operations Python supports and how to combine them in more complex expressions;
- a couple of other useful operations like calculation of the remainder of a division and exponentiation;
- operation priority in Python;
- how to write expressions according to PEP 8.



# Teoría: citas y cadenas de varias líneas

## Citas

Como sabe, un literal de cadena está rodeado por un par de **comillas** **simples** o **dobles** . Básicamente, no hay diferencia entre los dos, pero existen algunas convenciones comunes con respecto a su uso:

- Utilice comillas dobles si su cadena contiene comillas simples, por ejemplo `"You're doing great!"`,.
- Utilice comillas simples si su cadena contiene comillas dobles, por ejemplo `'Have you read "Hamlet"?'`,.
- ¡No mezcle dos estilos en un literal! Por ejemplo, algo como `"string!'`no es correcto.
- Lo más importante, ¡sea consistente en su uso!

Hay una forma de incluir las comillas en su cadena, independientemente del estilo de las comillas externas, y es usar el **símbolo de barra invertida** ( `\`) antes de las comillas dentro de la cadena. La barra invertida básicamente le dirá a Python que el símbolo de comillas que le sigue es parte de la cadena en lugar de su final o comienzo. Se llama **escapar** y lo aprenderá en detalle en los siguientes temas.

En los ejemplos siguientes, ambas formas de escribir cadenas son correctas y producirán el mismo resultado:

```python
# example 1
print("You're doing great!")
print('You\'re doing great!')
# example 2
print("Have you read \"Hamlet\"?")
print('Have you read "Hamlet"?')
```

## Cuerdas multilínea

Las cadenas pueden representar un texto largo, un solo carácter o incluso ningún carácter, como en el caso de una cadena vacía. Hasta ahora, una cosa ha sido cierta acerca de todos ellos: todas nuestras cadenas eran de una sola línea, sin importar cuán largas fueran. Sin embargo, también puede escribir cadenas de **varias líneas** en Python. Para hacer eso, necesita usar **comillas triples** en cada lado de la cadena literal. Nuevamente, la elección de comillas simples o dobles depende de usted, ya que ambas funcionan bien en Python.

Cadena de varias líneas entre comillas dobles:

```python
print("""This
is
a
multi-line
string""")
```

Cadena de varias líneas entre comillas simples:

```python
print('''This
is
a
multi-line
string''')
```

Ambos ejemplos imprimen el mismo resultado:

```no-highlight
This
is
a
multi-line
string
```

## Resumen

En este tema, hemos cubierto información básica sobre el uso de comillas en cadenas y vimos cómo escribir cadenas de varias líneas. Esto no es todo lo que puede hacer con cadenas en Python: hay mucho más que aprender y, lo que es más importante, ¡practicar!



# Teoría: secuencias de escape

Recordemos los problemas que puede encontrar al utilizar la `print()`función.

A nadie le gusta escribir palabras largas, así que aquí viene el apóstrofe. Sin embargo, tenga cuidado, al usar un apóstrofo en cadenas en Python, es posible que obtenga un mensaje de error. Echemos un vistazo al siguiente ejemplo:

```python
# Bad example

warning = 'That's my car'
print(warning)
```

La oración parece verse bien, pero Python le mostrará un mensaje de error « `EOL while scanning string literal`». ¿Por qué ocurrió ese error? La abreviatura "EOL" significa "End-of-line" y significa que Python revisó el texto y no encontró el final de la cadena. La oración se dividió en dos partes. El primero es `"That"`y el segundo es `"s my car"`.

## ¿Qué es una secuencia de escape?

Para evitar el problema descrito, debe utilizar **secuencias de escape** .

Todas las secuencias de escape comienzan con una barra invertida `\`, que se interpreta como un **carácter de escape** . Una barra invertida indica que uno o más caracteres deben manejarse de una manera especial o que el siguiente carácter tiene un significado diferente.

Agregue un carácter de escape a nuestro ejemplo y vea que la cita ahora se interpreta como el símbolo literal de una sola cita sin errores.

```python
# Better example
 
warning = 'That\'s my car'
print(warning)  # That's my car
```



¡No olvide que las comillas simples y un apóstrofe en la misma oración son un mal estilo! Según PEP8, es mejor utilizar comillas dobles en estos casos.



Se puede usar una barra invertida en combinación con otro símbolo para hacer algunas cosas en particular. Por ejemplo, si usa `\b`en el medio de la cadena y luego intenta imprimirlo, no verá el carácter antes `\b`. La combinación `\b` significa un carácter de retroceso:

```python
print('deleted\b sign')  # delete sign
```

Eche un vistazo a otras secuencias de escape:

- `\n` - nueva línea
- `\t` - tabulación horizontal
- `\r`- mueve todos los caracteres posteriores `\r`al principio de la línea, sobrescribiendo tantos caracteres como movidos.

El uso de secuencias de escape en una cadena es siempre el mismo. No obstante, daremos más ejemplos en la siguiente sección.

Entonces, ¿qué pasa si necesita imprimir la barra invertida?

```python
print('\')  # SyntaxError: EOL while scanning string literal
```

El error ocurre porque Python espera una secuencia de escape que no está allí. En este caso, debemos utilizar una doble barra invertida.`\\`

```python
print('\\')  # \
```

Se agrega un extra `\`para decirle a Python que la próxima `\`debería **no** ser interpretado como el inicio de una secuencia de escape.

Ahora, si desea imprimir el texto que contiene `\`, puede duplicarlo. Por ejemplo, esto es útil cuando necesita imprimir literalmente `\n`, porque `print('\n')`solo generará una nueva línea en blanco. ¡La doble barra invertida te ayudará en tales situaciones!

```python
print('\\n')  # \n
```

Y también puedes escribir:

```python
metal = '\m/'
print(metal)  # \m/
```

¿Por qué todo es correcto en tal caso? Nuestra cadena se `\`imprimió correctamente, porque `\m`no es una expresión de escape. Por lo tanto, no se ha producido ningún formateo. Un ejemplo más:

```python
face = '\^_^/'
print(face)  # \^_^/
```

La función `repr()`devuelve una representación imprimible de esta cadena, por lo que las secuencias de escape son visibles.

```python
print(repr(face))  # '\\^_^/'
```

Cuando queremos saber la longitud de una cadena, también se tienen en cuenta las secuencias de escape:

```python
print(len(repr(face)))  # 8
```

## Otros ejemplos

Consideremos un ejemplo con la secuencia de escape `\n`:

```python
# The new line

print('Hello \nWorld!')
```

La `\n `combinación comienza una nueva línea, por lo que verá el siguiente resultado:

```no-highlight
HelloWorld!
```

El siguiente ejemplo muestra la secuencia de escape `\t`. Como se dijo anteriormente, `\t` se utiliza para la tabulación. Si lo coloca en el medio de una cadena, las dos partes de la cadena se dividirán por un espacio en blanco que se llama tabulación. Es muy útil cuando trabaja con un texto.

```python
# The tabulationprint('Hello\tWorld!')  # Hello   World!
```

Otra secuencia de escape que puede resultar útil mientras trabaja con texto es `\r`. El nombre común de esta secuencia de escape es retorno de carro. Mueve los caracteres después `\r`al principio de la línea, reemplazando el número exacto de caracteres antiguos. Es decir, si la longitud de la cadena es más larga antes de esta secuencia de escape, solo se reescribe el número requerido de caracteres.

```python
# The characters removal print("Hello, dear \rWorld!")  # World! dear
```

¡Tenga en cuenta que la longitud de la cuerda sigue siendo la misma!

```python
print(len("Hello, dear \rWorld!"))  # 19
```

Las secuencias de escape son fáciles de usar, ¿no? Hablemos más sobre la longitud de las cuerdas. Por ejemplo:

```python
# Comparing the lengthsgreeting = 'Hello, John'nice_greeting = 'Hello, \nJohn'print(greeting)# Hello, Johnprint(nice_greeting)# Hello, # Johnprint(len(greeting))       # 11print(len(nice_greeting))  # 12
```

Después de llamar a la `len()`función, podemos ver que la longitud de la cadena con una secuencia de escape (en este caso `\n`) es mayor.

Tenga cuidado al trabajar con cadenas porque la función `print()`no muestra secuencias de escape.

## Resumen

Por lo tanto, en este tema, hemos introducido secuencias de escape básicas, sus características y hemos considerado varios ejemplos de cómo usarlas, ¡así que ahora puede trabajar con ellas en cadenas de Python!



# Teoría: recibir información

A veces, los programas necesitan interactuar con los usuarios, ya sea para recibir algunos datos o para entregar algún tipo de resultado. Y ahí es cuando la `input()` función se roba el show.

## Leer la entrada de un usuario

Los datos de entrada que queremos obtener no son más que un valor introducido por el usuario. La `input()`función lee este valor y lo devuelve en un programa como una cadena. Por ejemplo, el siguiente programa lee el nombre de usuario e imprime un saludo.

```python
user_name = input()print('Hello, ' + user_name)
```

En la primera línea, el programa esperará a que el usuario ingrese algo como entrada, que asignaremos a una variable para que podamos usarla más tarde. En la segunda línea, el programa agrega el nombre ingresado al final de la `'Hello, '`cadena e imprime la frase completa como resultado.

Si un usuario ingresa `Sauron`, este programa imprime:

```python
Hello, Sauron
```

Entonces, su programa imprime un resultado que depende de la entrada del usuario (nombre).

## Mensajes claros

Es muy recomendable indicar claramente qué tipo de información esperamos de nuestro usuario. Para hacerlo, la `input()`función puede tomar un argumento opcional, que es un mensaje:

```python
user_name = input('Please, enter your name: ')
print('Hello, ' + user_name)
```

El programa se inicia, el usuario ve el mensaje, ingresa su nombre y obtiene el resultado de la siguiente manera:

```no-highlight
Please, enter your name: Sauron
Hello, Sauron
```

Otra forma de hacer esto es imprimir el mensaje por separado:

```python
print('Enter your name: ')
user_name = input()
print('Hello, ' + user_name)
```

En realidad, no hay una gran diferencia: en el ejemplo anterior, la entrada se imprimirá en la misma línea que el mensaje, mientras que en este caso se escribirá en la siguiente línea. Entonces, puedes elegir lo que quieras.



Aunque se recomienda imprimir mensajes para los usuarios, evítelos en nuestros desafíos de programación educativa, de lo contrario su código puede no pasar nuestras pruebas.



## Detalles importantes

Profundicemos en algunos detalles. En primer lugar, ¿cuánto tiempo puede durar la entrada del usuario? La segunda pregunta es: ¿cómo entiende el programa que la persona ingresó todo lo que quería?

Aquí hay algo sobre la `input()`función: tan pronto como el programa ha comenzado a ejecutar esta función, se detiene y espera a que el usuario ingrese algún valor y **presione Enter** . Eso también significa que si no hay información del usuario, el programa no se ejecutará más.

¿Qué más deberías recordar? Bueno, esto: cualquier valor que ingrese, la función lo verá como una **cadena** . No importa si ingresa dígitos o letras, la entrada se convertirá en una cadena.

Si desea que un número sea un **número** , debe escribirlo explícitamente:

```python
print("What's your favorite number?")value = int(input())  # now value keeps an integer number
```

Sin embargo, tenga cuidado: en estas circunstancias, si un usuario ingresa un valor no entero, `Error`aparecerá un.

Para leer varias entradas, debe llamar a la función más de una vez:

```python
day = int(input())  # 4
month = input()     # October
```

¡Brillante! ¿Por qué esta fecha? Es simple:

```python
print('Cinnamon roll day is celebrated on', month, day)
# Cinnamon roll day is celebrated on October 4
```

## Conclusión

Enhorabuena, ahora sabes cómo trabajar con `input()`, es decir, una función que te ayuda a interactuar con el usuario. Créanos, esto es algo que definitivamente apreciará al programar.

# Theory: String formatting

Hay ciertas situaciones en las que desea hacer que sus cadenas de texto sean algo "dinámicas", es decir, hacer que cambien dependiendo del valor de una variable o expresión. Por ejemplo, desea solicitarle al usuario su nombre e imprimirle el saludo con el nombre que ingresó. Pero, ¿cómo se puede incrustar una variable en una cadena? Si lo hace de la forma más intuitiva, se sentirá decepcionado:

```python
a = input()print('Hello, a')
```

La salida será:

```python
Hello, a
```

Afortunadamente, Python ofrece una gran variedad de métodos para formatear la salida de la manera que desee y nos concentraremos en los dos principales:

- Literales de cadena formateados
- El `str.format()`metodo

Anteriormente, **el operador%** estaba en uso. Este operador integrado se derivó del lenguaje C y se usó en algunas situaciones de la siguiente manera:

**valor de cadena**

Por lo tanto, la variable a la derecha de `%`se incluyó en la cadena a la izquierda. Si quisiéramos dividir 11 entre 3, el `/`operador habría devuelto un número flotante con muchos lugares decimales.

```python
print(11 / 3)  # 3.6666666666666665
```

Con `%`carácter, podríamos controlar el número de posiciones decimales, por ejemplo, reducir su número a 3 o 2:

```python
print('%.3f' % (11/3))  # 3.667print('%.2f' % (11/3))  # 3.67print(round((11/3), 3)) # 3.667
```

Para cada operación, tenía que conocer muchos especificadores, modificadores de longitud y tipos de conversión. Una gran variedad de operadores adicionales condujo a algunos errores comunes. Es por eso que se introdujeron operadores más modernos y fáciles de usar. El progreso nunca se detiene, ¡lo sabes!

Dar formato a sus cadenas también hace que su código se vea más legible y fácilmente editable.

Siguiente sección ![img](https://hyperskill.azureedge.net/static/img/back-white.02e4bb70.svg)



## El str. método format ()

El funcionamiento del método ya está descrito en su nombre: en la **parte de cadena** , introducimos llaves como marcadores de posición para las variables enlistadas en la **parte de formato** :

```python
print('Mix {}, {} and a {} to make an ideal omelet.'.format('2 eggs', '30 g of milk', 'pinch of salt'))
```

Las expresiones se colocan en lugar de llaves en el orden en que se mencionaron:

```no-highlight
Mix 2 eggs, 30 g of milk and a pinch of salt to make an ideal omelet.
```

Puede usar la misma variable en una cadena más de una vez si es necesario. Además, puede abordar los objetos haciendo referencia a sus **posiciones** entre llaves (como de costumbre, *la numeración comienza desde cero* ). Atención: el orden que elijas puede ser muy importante. Los siguientes dos códigos:

```python
print('{0} in the {1} by Frank Sinatra'.format('Strangers', 'Night'))
```

y

```python
print('{1} in the {0} by Frank Sinatra'.format('Strangers', 'Night'))
```

tendrá diferentes salidas:

```no-highlight
Strangers in the Night by Frank Sinatra
Night in the Strangers by Frank Sinatra
```

La segunda salida suena realmente extraña, ¿no?

Si ha mencionado más variables de las necesarias en la parte de formato, las adicionales simplemente se ignorarán.

También podemos usar palabras clave para hacer que dichas cadenas sean más legibles. ¡No olvides que puedes romper las líneas fácilmente! Por ejemplo:

```python
print('The {film} at {theatre} was {adjective}!'.format(film='Lord of the Rings',
                                                        adjective='incredible',
                                                        theatre='BFI IMAX'))
```

Tenga en cuenta que también puede mezclar el orden como desee si usa palabras clave. Aquí está la cadena formateada:

```no-highlight
The Lord of the Rings at BFI IMAX was incredible!
```

Además, puede combinar argumentos posicionales y de palabras clave:

```python
print('The {0} was {adjective}!'.format('Lord of the Rings', adjective='incredible'))
# The Lord of the Rings was incredible!
```

Sin embargo, controle el orden de sus argumentos:

```python
print('The {0} was {adjective}!'.format(adjective='incredible', 'Lord of the Rings'))
# SyntaxError: positional argument follows keyword argument
```

El último fragmento de código resultó en `SyntaxError`, ya que los argumentos posicionales deben mencionarse primero.



Recuerde, como regla de Python, que los argumentos de palabras clave siempre se escriben **después de** argumentos posicionales o que no son palabras clave.



## Literales de cadena formateados

**Los literales de cadena formateados** (o, simplemente, **cadenas f** ) se utilizan para incrustar los valores de las expresiones dentro de los literales de cadena. Se supone que esta forma es la más fácil: solo necesita poner **f** antes de la cadena y poner las variables que desea incrustar en la cadena entre llaves. También son la característica más nueva entre todos los métodos de formato de cadenas en Python.

```python
name = 'Elizabeth II'title = 'Queen of the United Kingdom and the other Commonwealth realms'reign = 'the longest-lived and longest-reigning British monarch'f'{name}, the {title}, is {reign}.'
```

Si imprime esta cadena corta, verá una salida que es cinco veces más larga que su representación en el código:

```no-highlight
Elizabeth II, the Queen of the United Kingdom and the other Commonwealth realms, is the longest-lived and longest-reigning British monarch.
```

También puede usar diferentes especificaciones de formato con f-literales, por ejemplo, el redondeo de decimales se vería así:

```python
hundred_percent_number = 1823
needed_percent = 16
needed_percent_number = hundred_percent_number * needed_percent / 100

print(f'{needed_percent}% from {hundred_percent_number} is {needed_percent_number}')
# 16% from 1823 is 291.68

print(f'Rounding {needed_percent_number} to 1 decimal place is {needed_percent_number:.1f}')
# Rounding 291.68 to 1 decimal place is 291.7
```

Puede leer más sobre el mini-lenguaje de especificación de formato en Python en la [documentación oficial](https://docs.python.org/3.6/library/string.html#format-specification-mini-language) .

## Resumen

Por lo tanto, en este tema, hemos aprendido varias formas de formatear cadenas: usando% operator, método str.format () y f-strings. Quizás ahora piense que estos métodos no son importantes y están sobrevalorados, pero en la práctica, son bastante útiles y le brindan la oportunidad de hacer que su código se vea elegante y legible.



# Teoría: Programa con números

Los programas en los que no hay nada que calcular son bastante raros. Por lo tanto, aprender a programar con números nunca es una mala idea. Una habilidad aún más valiosa que estamos a punto de aprender es el procesamiento de los datos del usuario. Con su ayuda, puede crear aplicaciones interactivas y mucho más flexibles. ¡Entonces empecemos!

## Leer números de la entrada del usuario

Dado que se ha familiarizado con la `input()`función en Python, no es nuevo para usted que cualquier dato que se pase a esta función se trate como una **cadena** . Pero, ¿cómo debemos lidiar con los valores numéricos? Como regla general, se convierten explícitamente a los tipos numéricos correspondientes:

```python
integer = int(input())floating_point = float(input())
```

Preste atención a las mejores prácticas actuales: es crucial no nombrar sus variables como tipos integrados (por ejemplo, **float** o **int** ). Además, debemos tener en cuenta los errores del usuario: si un usuario escribe una entrada inexacta, digamos, una cadena 'dos'en lugar de un número 2, `ValueError`ocurrirá una. Por el momento, no nos centraremos en eso; pero no se preocupe, hay más información disponible sobre errores en un tema específico. Ahora, considere un ejemplo más detallado y pragmático de manejo de entradas numéricas.

## Millas aéreas gratuitas

Imagine que tiene una tarjeta de crédito con un programa de bonificación de millas aéreas gratis (o tal vez ya tenga una). Como usuario, se espera que ingrese la cantidad de dinero que gasta en promedio con esta tarjeta por mes. Supongamos que el programa de bonificación le otorga 2 millas aéreas gratuitas por cada dólar que gasta. Aquí hay un programa simple para descubrir cuándo puede viajar a algún lugar gratis:

```python
# the average amount of money per month
money = int(input("How much money do you spend per month: "))

# the number of miles per unit of money
n_miles = 2

# earned miles
miles_per_month = money * n_miles

# the distance between London and Paris
distance = 215

# how many months do you need to get
# a free trip from London to Paris and back
print(distance * 2 / miles_per_month)
```

Este programa calculará cuántos meses se necesitan para recorrer la distancia seleccionada y regresar.



Aunque se recomienda escribir mensajes para los usuarios en la `input()`función, evítelos en nuestros desafíos de programación educativa, de lo contrario su código puede no pasar nuestras pruebas.



## Formas avanzadas de asignación

Siempre que usa un signo igual `=`, en realidad asigna algún valor a un nombre. Por esa razón, `=`normalmente se lo denomina **operador de asignación** . Mientras tanto, hay otros operadores de asignación que puede usar en Python. También se denominan **operadores de asignación compuesta** , ya que realizan una operación aritmética y una asignación en un solo paso. Eche un vistazo al fragmento de código a continuación:

```python
# simple assignment
number = 10
number = number + 1  # 11
```

Este código es equivalente al siguiente:

```python
# compound assignment
number = 10
number += 1  # 11
```

Uno puede ver claramente en el ejemplo que la segunda parte del código es más concisa (ya que no repite el nombre de la variable).

Naturalmente, existen formas de asignación similares para el resto de operaciones aritméticas: `-=`, `*=`, `/=`, `//=`, `%=`, `**=`. Dada la oportunidad, úsalas para ahorrar tiempo y esfuerzo.

A continuación se presenta una posible aplicación de la asignación compuesta.

## Variable de contador

En programación, los bucles se utilizan junto con variables especiales llamadas **contadores** . Un **contador** cuenta cuántas veces se ejecuta un código en particular. También se deduce que los contadores deben ser números enteros. Ahora vamos al grano: puede usar los operadores `+=`y `-=`para aumentar o disminuir el contador respectivamente.

Considere este ejemplo donde un usuario determina el valor por el cual se incrementa el contador:

```python
counter = 1
step = int(input())  # let it be 3
counter += step
print(counter)  # it should be 4
```

En caso de que solo necesite números enteros no negativos del usuario (¡después de todo, estamos aumentando el contador!), Puede evitar entradas incorrectas utilizando la `abs()`función. Es una función incorporada de Python que devuelve el valor absoluto de un número (es decir, el valor independientemente de su signo). Reajustemos un poco nuestro último programa:

```python
counter = 1
step = abs(int(input()))  # user types -3
counter += step
print(counter)  # it's still 4
```

Como puede ver, gracias a la `abs()`función obtuvimos un número positivo.



Por ahora, está bien que no sepa mucho sobre los detalles mencionados de **errores** , **bucles** y **funciones integradas** en Python. Nos pondremos al día y nos aseguraremos de que conozca estos temas de manera integral. ¡Seguir aprendiendo!



## Conclusión

Por lo tanto, hemos arrojado algo de luz sobre nuevos detalles sobre la aritmética de enteros y el procesamiento de entradas numéricas en Python. No dude en utilizarlos en sus proyectos futuros.



# Teoría: Lista

En sus programas, a menudo necesita agrupar varios elementos para procesarlos como un solo objeto. Para ello, necesitará utilizar diferentes colecciones. Una de las colecciones más útiles de Python es una **lista** . Es una de las cosas más importantes de Python.

## Crear e imprimir listas

Mire una lista simple que almacena varios nombres de razas de perros:

```python
dog_breeds = ['corgi', 'labrador', 'poodle', 'jack russell']
print(dog_breeds)  # ['corgi', 'labrador', 'poodle', 'jack russell']
```

En la primera línea, usamos corchetes para crear una lista que contiene cuatro elementos y luego la asignamos a la `dog_breeds`variable. En la segunda línea, la lista se imprime a través del nombre de la variable. Todos los elementos se imprimen en el mismo orden en que se almacenaron en la lista porque las listas están **ordenadas** .

Aquí hay otra lista que contiene cinco números enteros:

```python
numbers = [1, 2, 3, 4, 5]
print(numbers)  # [1, 2, 3, 4, 5]
```

Otra forma de crear una lista es invocar la `list`función. Se utiliza para crear una lista a partir de un objeto **iterable** : es decir, un tipo de objeto en el que puede obtener sus elementos uno por uno. El concepto de iterabilidad se explicará en detalle más adelante, pero veamos los ejemplos a continuación:

```python
list_out_of_string = list('danger!')
print(list_out_of_string)  # ['d', 'a', 'n', 'g', 'e', 'r', '!']

list_out_of_integer = list(235)  # TypeError: 'int' object is not iterable
```

Entonces, la `list`función crea una lista que contiene cada elemento del objeto iterable dado. Por ahora, recuerde que una **cadena** es un ejemplo de un objeto **iterable** y un **número entero** es un ejemplo de un objeto **no iterable** . Una **lista en** sí misma también es un objeto **iterable** .

Notemos también la diferencia entre la `list`función y la creación de una lista usando corchetes:

```python
multi_element_list = list('danger!')
print(multi_element_list)  # ['d', 'a', 'n', 'g', 'e', 'r', '!']

single_element_list = ['danger!']
print(single_element_list)  # ['danger!']
```

Los corchetes y la `list`función también se pueden utilizar para crear **listas vacías** que no tienen ningún elemento.

```python
empty_list_1 = list()
empty_list_2 = []
```

En los siguientes temas, consideraremos cómo llenar listas vacías.

## Características de las listas

Las listas pueden almacenar **valores duplicados** tantas veces como sea necesario.

```python
on_off_list = ['on', 'off', 'on', 'off', 'on']
print(on_off_list)  # ['on', 'off', 'on', 'off', 'on']
```

Otro aspecto importante de las listas es que pueden contener **diferentes tipos** de elementos. Por lo tanto, no hay restricciones ni tipos de lista fijos, y puede agregar a su lista cualquier dato que desee, como en el siguiente ejemplo:

```python
different_objects = ['a', 1, 'b', 2]
```

## Longitud de una lista

A veces es necesario saber cuántos elementos hay en una lista. Hay una función incorporada llamada `len`que se puede aplicar a cualquier objeto **iterable** y devuelve simplemente la **longitud** de ese objeto.

Entonces, cuando se aplica a una lista, devuelve el número de elementos en esa lista.

```python
numbers = [1, 2, 3, 4, 5]
print(len(numbers))  # 5

empty_list = list()
print(len(empty_list))  # 0

single_element_list = ['danger!']
print(len(single_element_list))  # 1

multi_elements_list = list('danger!')
print(len(multi_elements_list))  # 7
```

En el ejemplo anterior, puede ver cómo `len()`funciona la función. Nuevamente, preste atención a la diferencia entre `list()`y `[]`según se aplica a las cadenas: es posible que no resulte en lo que esperaba.

## Resumen

Como resumen, observamos que las listas son:

- **ordenado** , es decir, cada elemento tiene una posición fija en una lista;
- **iterable** , es decir, puede obtener sus elementos uno por uno;
- capaz de almacenar **valores duplicados** ;
- capaz de almacenar **diferentes tipos de elementos** .

# Teoría: índices

Hay varios tipos de colecciones para almacenar datos en Python. Las colecciones de elementos ordenados posicionalmente se suelen denominar **secuencias** , y tanto las listas como las cadenas les pertenecen. Cada elemento de una lista, así como cada carácter de una cadena, tiene un **índice** que corresponde a su posición. Los índices se utilizan para acceder a elementos dentro de una secuencia. La indexación se *basa en cero* , por lo que si ve a una persona que cuenta desde cero, debe haber conocido a un programador.

## Índices de elementos

Para acceder a un elemento de una lista por su índice, debe utilizar **corchetes.** Agrega los corchetes después de la lista y, entre ellos, escribe el índice de un elemento que desea obtener.

No se olvide **,** los índices comienzan en 0, por lo que el índice del primer elemento es 0. El índice del último elemento es igual `len(list) - 1`.

Echemos un vistazo al siguiente ejemplo:

```python
colors = ['red', 'green', 'blue']

first_elem = colors[0]   # 'red'
second_elem = colors[1]  # 'green'
third_elem = colors[2]   # 'blue'
```

Las cadenas funcionan de la misma manera:

```python
pet = "cat"

first_char = pet[0]   # 'c'
second_char = pet[1]  # 'a'
third_char = pet[2]   # 't'
```

## Peligros potenciales

Al usar índices, es importante mantenerse dentro del rango de su secuencia: obtendrá un error (llamado `IndexError`) si intenta acceder a un elemento con un índice no existente.

```python
colors = ['red', 'green', 'blue']
pet = "cat"

print(colors[3])  # IndexError: list index out of range
print(pet[3])     # IndexError: string index out of range
```

Hay un obstáculo más en tu camino. Imagina que quieres cambiar uno de los elementos de una lista. Se puede hacer fácilmente:

```python
colors = ['red', 'green', 'blue']

colors[1] = 'white'
print(colors)  # ['red', 'white', 'blue']
```

Sin embargo, cuando se trata de cadenas, dicha reasignación es imposible. Las cadenas, a diferencia de las listas, son inmutables, por lo que no puede modificar su contenido con índices:

```python
pet = "cat"

pet[0] = "b"
# TypeError: 'str' object does not support item assignment
```

No se preocupe, después de un poco de práctica, no encontrará estos errores.

## Índices negativos

La forma más fácil de acceder a los elementos al final de una lista o una cadena es usar **índices negativos** : el menos antes del número cambia tu perspectiva de alguna manera y miras la secuencia desde el final. Entonces, el último elemento de una lista, en este caso, tiene el índice igual a **-1** , y el primer elemento de la lista tiene el índice `-len(list)`(la longitud de la lista).

Por ejemplo:

```python
colors = ['red', 'green', 'blue']

last_elem = colors[-1]    # 'blue'
second_elem = colors[-2]  # 'green'
first_elem = colors[-3]   # 'red'

pet = "cat"

last_char = pet[-1]    # 't'
second_char = pet[-2]  # 'a'
first_char = pet[-3]   # 'c'
```

Como puede ver, funciona igual para listas y cadenas.

Si escribe un índice negativo no existente, también obtendrá `IndexError`. Tenga cuidado con los índices para evitar errores uno por uno en su código.

La siguiente imagen muestra el concepto general de índices en una lista:

[![img](https://camo.githubusercontent.com/d4db783d6654d3460374edd051f05512ae7cb36c88cadf10b95e29c3b254367f/68747470733a2f2f756361726563646e2e636f6d2f35343835663339372d386132662d343237392d623533342d6134393666653530393436392f)](https://camo.githubusercontent.com/d4db783d6654d3460374edd051f05512ae7cb36c88cadf10b95e29c3b254367f/68747470733a2f2f756361726563646e2e636f6d2f35343835663339372d386132662d343237392d623533342d6134393666653530393436392f)

## Resumen

En este tema, hemos aprendido qué son los índices positivos y negativos en Python, cómo encontrar elementos en una lista por sus índices y qué errores pueden ocurrir al usarlos. Dado que ha aprendido el concepto de índices, esperamos que a partir de ahora no encuentre dificultades al utilizarlos.

# Teoría: invocar una función

Aunque invocar funciones en Python no se trata de lanzar un hechizo o algo parecido, a veces funciona de maravilla. Empecemos por el concepto. Básicamente, una **función** es un fragmento estructurado de código que podemos querer usar en más de un lugar y más de una vez. Por otro lado, las funciones nos permiten leer mucho mejor tanto nuestro código como el de otra persona. ¿Aún no se han convertido en tus favoritos?

Aquí hay una llamada de función simple:

```python
multiply(1, 7)
```

Aquí `multiply`está el nombre de la función y los números entre paréntesis `(1, 7)`son sus **argumentos** . ¿Qué es un argumento? Bueno, es solo un valor, que se usará dentro del cuerpo de la función. ¡Vamos a profundizar más en ello!

## Invocando print ()

Para **llamar** , o **invocar** , **una función** en su programa, simplemente escriba su nombre y agregue paréntesis después. ¡Eso es todo lo que se necesita! Dato curioso: si alguna vez ha escrito una expresión como esta `print("Hello, world!")`, ya sabe un poco sobre funciones. En este pequeño ejemplo, sin embargo, vemos el mensaje"¡Hola Mundo!"entre paréntesis después del nombre de la `print`función. ¿Qué significa? Esta cadena es solo un argumento. Y la mayoría de las veces, las funciones tienen argumentos. En cuanto a la `print`función, también podemos usarla sin ningún argumento o incluso con múltiples argumentos:

```python
print("Hello, world!")
print()
print("Bye,", "then!")
```

Y aquí está la salida:

```python
Hello, world!

Bye, then!
```

Entonces, la primera llamada imprime una cadena, la segunda llamada `print`sin argumentos imprime, de hecho, una línea vacía y la última llamada genera nuestros dos mensajes como una expresión. ¿Le sorprenden estos resultados? Luego, puede aprender cómo `print`funciona la función con más detalle en su [documentación](https://docs.python.org/3/library/functions.html#print) . La documentación de Python contiene todo tipo de información sobre la función de su interés, por ejemplo, qué argumentos espera.

## Funciones integradas

Las funciones pueden hacer la vida más fácil, siempre que uno sea consciente de su existencia. Muchos algoritmos ya están escritos, por lo que no es necesario reinventarlos, excepto quizás con fines educativos. El intérprete de Python tiene una serie de funciones y tipos **integrados** , por lo que siempre están disponibles. Actualmente, el número de [funciones integradas asciende a 69](https://docs.python.org/3/library/functions.html) (en la última versión **Python 3.8** ). Algunos de ellos se utilizan para convertir el **tipo de objeto** , por ejemplo, `str()`devuelve una cadena, `int()`devuelve un entero, `float()`devuelve un número de punto flotante. Otros se ocupan de los **números** : puedes `round()`ellos y `sum()`ellos, encuentra el mínimo `min()`o el máximo`max()`. Otros más nos dan información sobre el objeto: su `type()`longitud `len()`. ¡Considérelos en acción!

En el siguiente ejemplo, `len()`cuenta el número de caracteres de la cadena (lo mismo ocurre con cualquier **secuencia** ).

```python
number = "111"

# finding the length of an object
print(len(number))  # 3
```

Luego declaramos las variables `integer`y `float_number`y escribir su suma en `my_sum`. Por cierto, la `sum()`función también se ocupa de secuencias.

```python
# converting types
integer = int(number)
float_number = float(number)
print(str(float_number))  # "111.0"

# adding and rounding numbers
my_sum = sum((integer, float_number))
```

El resultado es un número de punto flotante, que se aclara después de la impresión `my_sum`.

```python
print(my_sum)  # 222.0
print(round(my_sum))  # 222
```

Además, puede ver cómo encontrar los valores mínimo y máximo: el número más pequeño es igual a 111 y el mayor numero 222.0 pertenece a los flotadores.

```python
# finding the minimum and the maximum
print(min(integer, float_number))  # 111
print(type(max(integer, float_number, my_sum)))  # <class 'float'>
```

Hay mucho más por explorar, pero resumámoslo.

```python
jack_age = int(input())
alex_age = int(input())
lana_age = int(input())

print(min(jack_age, alex_age, lana_age))
```



## Resumen

La belleza de las funciones es que podemos usarlas sin tener una idea clara de su estructura interna y cómo se las arreglan para realizar lo que necesitamos. Pero si desea darle un buen uso a una función, asegúrese de verificar su documentación o intente invocar la función especial `help()`con el nombre de la función en cuestión entre paréntesis. Puede ser necesario si, por ejemplo, la función no devuelve ningún valor, escribe los datos procesados en un archivo o imprime la salida en la pantalla.

Hagamos un breve resumen:

- Las funciones están destinadas a ser reutilizables, lo que significa que podemos aplicarlas varias veces con diferentes argumentos,
- para llamar a una función escriba su nombre seguido de paréntesis y coloque los argumentos dentro,
- normalmente, una función tiene documentación, lo que a veces puede ser de gran ayuda.





# Teoría: invocar una función

Aunque invocar funciones en Python no se trata de lanzar un hechizo o algo parecido, a veces funciona de maravilla. Empecemos por el concepto. Básicamente, una **función** es un fragmento estructurado de código que podemos querer usar en más de un lugar y más de una vez. Por otro lado, las funciones nos permiten leer mucho mejor tanto nuestro código como el de otra persona. ¿Aún no se han convertido en tus favoritos?

Aquí hay una llamada de función simple:

```python
multiply(1, 7)
```

Aquí `multiply`está el nombre de la función y los números entre paréntesis `(1, 7)`son sus **argumentos** . ¿Qué es un argumento? Bueno, es solo un valor, que se usará dentro del cuerpo de la función. ¡Vamos a profundizar más en ello!

## Invocando print ()

Para **llamar** , o **invocar** , **una función** en su programa, simplemente escriba su nombre y agregue paréntesis después. ¡Eso es todo lo que se necesita! Dato curioso: si alguna vez ha escrito una expresión como esta `print("Hello, world!")`, ya sabe un poco sobre funciones. En este pequeño ejemplo, sin embargo, vemos el mensaje"¡Hola Mundo!"entre paréntesis después del nombre de la `print`función. ¿Qué significa? Esta cadena es solo un argumento. Y la mayoría de las veces, las funciones tienen argumentos. En cuanto a la `print`función, también podemos usarla sin ningún argumento o incluso con múltiples argumentos:

```python
print("Hello, world!")
print()
print("Bye,", "then!")
```

Y aquí está la salida:

```python
Hello, world!Bye, then!
```

Entonces, la primera llamada imprime una cadena, la segunda llamada `print`sin argumentos imprime, de hecho, una línea vacía y la última llamada genera nuestros dos mensajes como una expresión. ¿Le sorprenden estos resultados? Luego, puede aprender cómo `print`funciona la función con más detalle en su [documentación](https://docs.python.org/3/library/functions.html#print) . La documentación de Python contiene todo tipo de información sobre la función de su interés, por ejemplo, qué argumentos espera.

## Funciones integradas

Las funciones pueden hacer la vida más fácil, siempre que uno sea consciente de su existencia. Muchos algoritmos ya están escritos, por lo que no es necesario reinventarlos, excepto quizás con fines educativos. El intérprete de Python tiene una serie de funciones y tipos **integrados** , por lo que siempre están disponibles. Actualmente, el número de [funciones integradas asciende a 69](https://docs.python.org/3/library/functions.html) (en la última versión **Python 3.8** ). Algunos de ellos se utilizan para convertir el **tipo de objeto** , por ejemplo, `str()`devuelve una cadena, `int()`devuelve un entero, `float()`devuelve un número de punto flotante. Otros se ocupan de los **números** : puedes `round()`ellos y `sum()`ellos, encuentra el mínimo `min()`o el máximo`max()`. Otros más nos dan información sobre el objeto: su `type()`longitud `len()`. ¡Considérelos en acción!

En el siguiente ejemplo, `len()`cuenta el número de caracteres de la cadena (lo mismo ocurre con cualquier **secuencia** ).

```python
number = "111"

# finding the length of an object
print(len(number))  # 3
```

Luego declaramos las variables `integer`y `float_number`y escribir su suma en `my_sum`. Por cierto, la `sum()`función también se ocupa de secuencias.

```python
# converting types
integer = int(number)
float_number = float(number)
print(str(float_number))  # "111.0"

# adding and rounding numbers
my_sum = sum((integer, float_number))
```

El resultado es un número de punto flotante, que se aclara después de la impresión `my_sum`.

```python
print(my_sum)  # 222.0
print(round(my_sum))  # 222
```

Además, puede ver cómo encontrar los valores mínimo y máximo: el número más pequeño es igual a 111 y el mayor numero 222.0 pertenece a los flotadores.

```python
# finding the minimum and the maximum
print(min(integer, float_number))  # 111
print(type(max(integer, float_number, my_sum)))  # <class 'float'>
```

Hay mucho más por explorar, pero resumámoslo.

## Resumen

La belleza de las funciones es que podemos usarlas sin tener una idea clara de su estructura interna y cómo se las arreglan para realizar lo que necesitamos. Pero si desea darle un buen uso a una función, asegúrese de verificar su documentación o intente invocar la función especial `help()`con el nombre de la función en cuestión entre paréntesis. Puede ser necesario si, por ejemplo, la función no devuelve ningún valor, escribe los datos procesados en un archivo o imprime la salida en la pantalla.

Hagamos un breve resumen:

- Las funciones están destinadas a ser reutilizables, lo que significa que podemos aplicarlas varias veces con diferentes argumentos,
- para llamar a una función escriba su nombre seguido de paréntesis y coloque los argumentos dentro,
- normalmente, una función tiene documentación, lo que a veces puede ser de gran ayuda.

```python
x = int(input())

y = int(input())

print(sum([x], y))
```

> Un dato curioso sobre `min()`y `max()`es que estas funciones pueden ayudarlo a ordenar en orden alfabético. Si se pasa una cadena como argumento, `min()`devolverá la primera letra (alfabéticamente) y `max()`la última (algo zetabéticamente). Y si especifica más de un valor, `min()`devolverá la primera cadena en orden alfabético y `max()`, en cambio, la última. Por ejemplo, `min("alpha", "omega")`te da `"alpha"`, mientras que `max("alpha", "omega")`devuelve `"omega"`.

# Teoría: declarar una función

A menudo, las funciones integradas no son suficientes ni siquiera para los principiantes. En tal caso, no hay más remedio que crear su propia función usando la palabra clave `def`(derecha, derivada de **definir** ). Echemos un vistazo a la sintaxis:

```python
def function_name(parameter1, parameter2, ...):    # function's body    ...    return "return value"
```

Después `def`, escribimos el nombre de nuestra función (para poder invocarla más tarde) y los nombres de los **parámetros** , que nuestra función puede aceptar, entre paréntesis. No se pierda los dos puntos al final de la línea. Los nombres de una función y sus parámetros siguen la misma convención que los **nombres de las variables** , es decir, deben escribirse en **minúsculas con guiones bajos entre las palabras** .

Una sangría de 4 espacios muestra al intérprete dónde comienza y dónde termina el cuerpo de la función. Todas las declaraciones del cuerpo de la función deben tener sangría. Puede hacer cálculos dentro de su función y usar la `return`palabra clave para devolver el resultado. Solo cuando no hay sangría, finaliza la definición de la función.

Posteriormente, los parámetros toman valores pasados en una llamada de función. Los valores que pasamos a una función se conocen como **argumentos** . La única distinción entre parámetros y argumentos es que introducimos parámetros en una definición de función y damos argumentos (algunos valores específicos) en una llamada de función. Aquí hay un ejemplo un poco menos abstracto de una función:

```python
# Function definition
def multiply(x, y):
    return x * y


# Function calls
a = multiply(3, 5)   # 15
b = multiply(a, 10)  # 150
```

En caso de que no desee pasar ningún argumento, los corchetes permanecen vacíos:

```python
def welcome():
    print("Hello, people!")
```

También puede declarar una especie de función vacía con la `pass`declaración:

```python
# This function does nothing (yet)
def lazy_func(param):
    pass
```

Cuando elige llamar `lazy_func()`con un valor arbitrario como argumento, no sucederá nada. Entonces `pass`es solo un marcador de posición, pero al menos su código será válido con él.

```python
# CALCULADORA
def suma(x, y):
    return x + y


def resta(x, y):
    return x - y


def multi(x, y):
    return x * y


def div(x, y):
    return x / y


def main():
    opc = input('opc:  ')
    x = int(input('x:  '))
    y = int(input('y:  '))
    if opc == 'a':
        a = suma(x, y)
        print(a)

    elif opc == 'b':
        a = resta(x, y)
        print(a)

    elif opc == 'c':
        a = multi(x, y)
        print(a)

    elif opc == 'd':
        a = div(x, y)
        print(a)

    main()

if __name__ == '__main__':
    main()
```



## Parámetros vs argumentos

No está del todo claro en este momento, ¿cuáles son los parámetros, verdad? De hecho, los parámetros son solo alias de valores, que se pueden pasar a una función. Considere el siguiente ejemplo:

```python
def send_postcard(address, message):
    print("Sending a postcard to", address)
    print("With the message:", message)


send_postcard("Hilton, 97", "Hello, bro!")
# Sending a postcard to Hilton, 97
# With the message: Hello, bro!

send_postcard("Piccadilly, London", "Hi, London!")
# Sending a postcard to Piccadilly, London
# With the message: Hi, London!

# Se muestra que realizar con los argumentos al ser invocados
```

Como puede ver, esta función es un fragmento de código reutilizable, que se puede ejecutar con diferentes argumentos, es decir, diferentes valores pasados a esta función. Aquí, `address`y `message`son solo alias, bajo los cuales la función recibe valores y luego los procesa en el cuerpo.

Esta función toma exactamente 2 argumentos, por lo que no podrá ejecutarla con más o menos de 2 argumentos:

```python
send_postcard("Big Ben, London")

TypeError: send_postcard() missing 1 required positional argument: 'message'
```

## Ejecución y devolución

Nuestra función anterior solo realizaba algunas acciones, pero no tenía ningún **valor de retorno** . Sin embargo, es posible que desee calcular algo en una función y devolver el resultado en algún momento. Mira el siguiente ejemplo:

```python
def celsius_to_fahrenheit(temps_c):
    temps_f = temps_c * 9 / 5 + 32
    return round(temps_f, 2)


# Convert the boiling point of water
water_bp = celsius_to_fahrenheit(100)
print(water_bp)  # 212.0
```

La palabra clave `return`se utiliza para indicar qué valores genera la función. Básicamente, es el resultado de la llamada a la función. Entonces, en el ejemplo anterior, hemos almacenado el valor devuelto por nuestra función en la variable `water_bp`. Solo para estar seguros, imprimimos el resultado.

Una cosa más que decir es que las funciones no necesariamente tienen valores de retorno. La `print()`función conocida , de hecho, no devuelve nada. Examine el siguiente código:

```python
chant = print("We Will Rock You")
print(chant)
```

Y su salida:

```python
We Will Rock You
None
```

Declaramos la variable `chant`e invocamos `print()`. Obviamente, la función se ejecutó. Pero la variable en sí resultó ser el objeto **None** , lo que significa que la función llamada no tenía nada que devolver. El valor de `chant`es **Ninguno** .



El intérprete de Python deja de realizar la función después `return`. Pero, ¿qué pasa si el cuerpo de la función contiene **más** de una declaración de retorno? Entonces la ejecución terminará después de la primera. ¡Por favor tenlo en mente!



## Resumen

Por lo tanto, hemos aprendido la sintaxis para declarar funciones. Ahora también sabes que:

- Los parámetros de una función son simplemente alias o marcadores de posición para los valores que les pasará. Los parámetros se reinicializan cada vez que llama a la función. Dentro de la función, tiene acceso a estos valores, lo que significa que puede realizar cálculos sobre ellos.
- Una función puede simplemente realizar una acción sin devolver nada o devolver un resultado específico. Si su función no devuelve nada, asignar su resultado a una variable o imprimirlo le dará `None`.

Declarar sus propias funciones hace que su código sea más estructurado y reutilizable. Siempre que utilice el mismo código más de una vez, intente crear una función.

> En Hyperskill, a veces necesitamos verificar que el código del estudiante no use un método en particular. Por ejemplo, cuando la tarea es implementar el cálculo de factorial manualmente en lugar de usar la función `factorial()`del `math`módulo. ¿Cómo podríamos hacer eso?
>
> De hecho, es realmente sencillo. Podemos *anular* `math.factorial()` para hacer otra cosa: generar un error o imprimir un mensaje al alumno. Para hacerlo, primero definimos una función que hace lo que queremos (por ejemplo, imprime un mensaje) y luego le asignamos esta función `math.factorial`. Ahora, si el estudiante intenta usar `math.factorial`, se generará nuestra función personalizada. Esto sucede porque cuando existen varias funciones con el mismo nombre, la última siempre anula a la anterior.

For this task, imagine that you are a Hyperskill content creator and implement the example with the factorial yourself. Your program should override `math.factorial()` and make it print the message `"Don't cheat!"` instead of actually calculating a factorial.

```python
import math


def cheat(x):
    print("Don't cheat!")


math.factorial = cheat

# don't delete this line, please
math.factorial(23)
###
import math
math.factorial = lambda x: print("Don't cheat!")
num = 23

math.factorial(num)
```



```python
# EJEMPLO
Wow! This problem is kind of tricky. If you're ready to put your thinking cap on, brace yourself and good luck! Otherwise, you can skip it for now and return any time later!
The function closest_higher_mod_5 takes exactly one integer argument x and returns the smallest integer y such that:

y is greater than or equal to x,
y is divisible by 5.
Correct the last line of the code below to make the function work.

Sample Input 1:

40
Sample Output 1:

40
Sample Input 2:

43
Sample Output 2:

45

def closest_higher_mod_5(x):
    remainder = x % 5
    if remainder == 0:
        return x
    return x + 5 - remainder

```

```python
# OTRO EJEMPLO

def fahrenheit_to_celsius(f):
    a = 32
    return round((f - a) * 5 / 9, 3)
```





# Teoría: alcances (Scopes)

Un **scope** es una parte del programa donde se puede llegar a una determinada variable por su nombre. El alcance es un concepto muy importante en programación porque define la visibilidad de un nombre dentro del bloque de código.

##### Global frente a local

Cuando define una variable, se vuelve **global** o **local** . Si una variable se define en el nivel superior del módulo, se considera global. Eso significa que puede hacer referencia a esta variable desde cada bloque de código en su programa. Las variables globales pueden ser útiles cuando necesita compartir información de estado o alguna configuración entre diferentes funciones. Por ejemplo, puede almacenar el nombre de un usuario actual en una variable global y luego usarlo donde sea necesario. Hace que su código sea más fácil de cambiar: para establecer un nuevo nombre de usuario, solo tendrá que cambiar una única variable.

Las variables locales se crean cuando las define en el cuerpo de una función. Entonces, su nombre solo se puede resolver dentro del alcance de la función actual. Le permite evitar problemas con los efectos secundarios que pueden ocurrir al usar variables globales.

Considere el ejemplo para ver la diferencia entre las variables globales y locales:

```python
phrase = "Let it be"

def global_printer():
    print(phrase)  # we can use phrase because it's a global variable

global_printer()  # Let it be is printed
print(phrase)  # we can also print it directly

phrase = "Hey Jude"

global_printer()  # Hey Jude is now printed because we changed the value of phrase

def printer():
    local_phrase = "Yesterday"
    print(local_phrase)  # local_phrase is a local variable

printer()  # Yesterday is printed as expected

print(local_phrase)  # NameError is raised
```

Por lo tanto, se puede acceder a una variable global tanto desde el nivel superior del módulo como desde el cuerpo de la función. Por otro lado, una variable local solo es visible dentro del alcance más cercano y no se puede acceder desde el exterior.

##### Regla LEGB

Una resolución variable en Python sigue la **regla LEGB** . Eso significa que el intérprete busca un nombre en el siguiente orden:

1. **Locales** . Variables definidas dentro del cuerpo de la función y no declaradas globales.
2. **Adjuntando** . Nombres del ámbito local en todas las funciones adjuntas desde el interior al exterior.
3. **Global** **s** . Nombres definidos en el nivel superior de un módulo o declarados globales con una `global`palabra clave.
4. **Incorporado** . Cualquier nombre integrado en Python.

Consideremos un ejemplo para ilustrar la regla LEGB:

```python
x = "global"
def outer():
    x = "outer local"
    def inner():
        x = "inner local"
        def func():
            x = "func local"
            print(x)
        func()
    inner()

outer()  # "func local"
```

Cuando se llama a la `print()`función dentro del, `func()`el intérprete necesita resolver el nombre `x`. Primero observará las variables más internas y buscará la definición local de `x`en `func()`función. En el caso del código anterior, el intérprete encontrará el local `x`in `func()`correctamente e imprimirá su valor `'func local'`,. [Aquí](https://pythontutor.com/visualize.html#code=x %3D "global" def outer()%3A    x %3D "outer local"    def inner()%3A        x %3D "inner local"        def func()%3A            x %3D "func local"            print(x)        func()    inner() outer()  %23 "func local"&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=[]&textReferences=false) está la visualización del código. ¡Compruébalo para ver cómo funciona casi en tiempo real!

Pero, ¿y si no hay una definición de `x`en `func()`? Luego, el intérprete se moverá hacia afuera y comenzará a `inner()`funcionar. Mira el siguiente ejemplo:

```python
x = "global"
def outer():
    x = "outer local"
    def inner():
        x = "inner local"
        def func():
            print(x)
        func()
    inner()

outer()  # "inner local"
```

Como ves, el nombre `x`se resolvió en `inner()`función, ya que `"inner local"`se imprimió el valor .

Si también eliminamos la definición de `x`de la `inner()`función y ejecutamos el código nuevamente, el intérprete continuará la búsqueda entre los `outer()`locales de la misma manera. Si seguimos eliminando las líneas de definición de código `x`, el intérprete pasará a los `outer()`locales, luego a los globales y luego a los nombres integrados. En caso de que no haya un nombre integrado que coincida, se generará un error. Mire el ejemplo donde `x`el intérprete llega a la definición global de :

```python
x = "global"
def outer():
    def inner():
        def func():
            print(x)
        func()
    inner()

outer()  # "global"
```

No te olvides de la regla LEGB si planeas usar funciones adjuntas.

##### Palabras clave "no local" y "global"

Ya mencionamos una forma de asignar una variable global: hacer una definición en el nivel superior de un módulo. Pero también hay una palabra clave especial `global`que nos permite declarar una variable global dentro del cuerpo de una función.

No puede cambiar el valor de una variable global dentro de la función sin usar la `global`palabra clave:

```python
x = 1
def print_global():
    print(x)

print_global()  # 1

def modify_global():
    print(x)
    x = x + 1

modify_global()  # UnboundLocalError
```

Se genera un error porque estamos tratando de asignar a una variable local `x`la expresión que contiene `x`y el intérprete no puede encontrar esta variable en un ámbito local. Para corregir este error, debemos declarar `x`global:

```python
x = 1
def global_func():
    global x
    print(x)
    x = x + 1

global_func()  # 1
global_func()  # 2
global_func()  # 3
```

Cuando `x`es global, puede incrementar su valor dentro de la función.

`nonlocal` La palabra clave nos permite asignar variables en el ámbito externo (pero no global):

```python
def func():
    x = 1
    def inner():
        x = 2
        print("inner:", x)
    inner()
    print("outer:", x)

def nonlocal_func():
    x = 1
    def inner():
        nonlocal x
        x = 2
        print("inner:", x)
    inner()
    print("outer:", x)

func()  # inner: 2
        # outer: 1

nonlocal_func()  # inner: 2
                 # outer: 2
```

Aunque `global`y `nonlocal`están presentes en el idioma, no se usan a menudo en la práctica, porque estas palabras clave hacen que los programas sean menos predecibles y más difíciles de entender.

##### ¿Por qué necesitamos osciloscopios?

En primer lugar, ¿por qué Python necesita la distinción entre alcance global y local? Bueno, a partir de la experiencia de algunos otros lenguajes de programación que no tienen ámbitos *locales* , quedó claro que usar solo un ámbito global es muy inconveniente: cuando se puede acceder a todas las variables desde todas las partes del código, es inevitable un montón de errores. Cuanto más largo sea el código, más difícil será recordar todos los nombres de las variables y no cambiar accidentalmente el valor de la variable que se suponía que debía mantener intacta. Por lo tanto, Python le ahorra problemas al permitirle "aislar" algunas variables del resto del código cuando lo divide en funciones.

Por otro lado, ¿por qué entonces necesitamos *un* alcance *global* ? Bueno, como ya se mencionó anteriormente, el alcance global es una de las formas más fáciles de retener información entre llamadas a funciones: mientras que las variables locales desaparecen en el momento en que la función regresa, las variables globales permanecen y ayudan a las funciones a transferir los datos necesarios entre sí. De manera similar, las variables globales pueden permitir la comunicación entre procesos más complejos, como subprocesos en aplicaciones multiproceso.

##### Resumen

En este tema, hemos descubierto la diferencia entre las variables globales y locales y las palabras clave "no locales" y "globales", hemos aprendido la regla LEGB y cómo los ámbitos pueden ser útiles en la práctica. ¡Espero que encuentre útil este nuevo conocimiento!





# Teoría: métodos básicos de cadena

Como ya sabe, la cadena es uno de los tipos de datos más importantes en Python. Para facilitar el trabajo con cadenas, Python tiene muchos métodos especiales de cadena incorporados. Estamos a punto de conocer algunos de ellos.



Sin embargo, es importante recordar que la cadena es un tipo de datos **inmutable** . Significa que no puede simplemente cambiar la cadena en el lugar, por lo que la mayoría de los métodos de cadena **devuelven una copia** de la cadena (con varias excepciones). Para guardar los cambios realizados en la cadena para su uso posterior, debe crear una **nueva variable** para la copia que realizó o **asignar el mismo nombre** a la copia. Entonces, qué hacer con la salida de los métodos depende de si va a usar la cadena original o su copia más adelante.



## "Cambiar" una cadena

El primer grupo de métodos de cadena consiste en los que "cambian" la cadena de una manera específica, es decir, devuelven la copia con algunos cambios realizados.

La sintaxis para llamar a un método es la siguiente: primero se proporciona una cadena (o el nombre de una variable que contiene una cadena), luego aparece un punto seguido del nombre del método y paréntesis en los que se enumeran los argumentos.

Aquí hay una lista de métodos de cadena comunes de ese tipo:

- **`str.replace(old, new, count)`**reemplaza todas las apariciones de la `old`cadena con `new`uno. El `count`parámetro es opcional y, si se especifica, solo `count`se reemplazan las primeras apariciones en la cadena dada.
- **`str.upper()`** convierte todos los caracteres de la cadena a mayúsculas.
- **`str.lower()`** convierte todos los caracteres de la cadena a minúsculas.
- **`str.title()`** convierte el primer carácter de cada palabra a mayúsculas.
- **`str.swapcase()`** convierte mayúsculas a minúsculas y viceversa.
- **`str.capitalize()`** cambia el primer carácter de la cadena a mayúsculas y minúsculas y el resto a minúsculas.

Y aquí hay un ejemplo de cómo se utilizan estos métodos (tenga en cuenta que no guardamos el resultado de cada método):

```python
message = "bonjour and welcome to Paris!"

print(message.upper())  # BONJOUR AND WELCOME TO PARIS!
# `message` is not changed
print(message)  # bonjour and welcome to Paris!

title_message = message.title() 
# `title_message` contains a new string with all words capitalized
print(title_message)  # Bonjour And Welcome To Paris!

print(message.replace("Paris", "Lyon"))  # bonjour and welcome to Lyon!
replaced_message = message.replace("o", "!", 2)
print(replaced_message)  # b!nj!ur and welcome to Paris!

# again, the source string is unchanged, only its copy is modified
print(message)  # bonjour and welcome to Paris!
```

## "Editar" una cadena

A menudo, cuando lee una cadena de algún lugar (un archivo o la entrada), debe editarla para que contenga solo la información que necesita. Por ejemplo, la cadena de entrada puede tener muchos espacios en blanco innecesarios o algunas combinaciones de caracteres finales. Los "edición" métodos que pueden ayudar a que son **`strip()`**, **`rstrip()`**y **`lstrip()`**.

- **`str.lstrip([chars])`**elimina los caracteres principales (es decir, caracteres del lado izquierdo). Si `chars`no se especifica el argumento , se eliminan los espacios en blanco iniciales.
- **`str.rstrip([chars])`**elimina los caracteres finales (es decir, caracteres del lado derecho). El valor predeterminado para el argumento `chars`también es un espacio en blanco.
- **`str.strip([chars])`**elimina tanto los caracteres iniciales como los finales. El valor predeterminado es el espacio en blanco.

El `chars`argumento, cuando se especifica, es una cadena de caracteres que deben eliminarse del final o del principio de la palabra (según el método que esté utilizando). Mira como funciona:

```python
whitespace_string = "     hey      "
normal_string = "incomprehensibilities"

# delete spaces from the left side
whitespace_string.lstrip()  # "hey      "

# delete all "i" and "s" from the left side
normal_string.lstrip("is")  # "ncomprehensibilities"

# delete spaces from the right side
whitespace_string.rstrip()  # "     hey"

# delete all "i" and "s" from the right side
normal_string.rstrip("is")  # "incomprehensibilitie"

# no spaces from both sides
whitespace_string.strip()  # "hey"

# delete all trailing "i" and "s" from both sides
normal_string.strip("is")  # "ncomprehensibilitie"
```

Tenga en cuenta que los métodos `strip()`, `lstrip()`y `rstrip()`eliminan todas las combinaciones posibles de caracteres especificados:

```python
word = "Mississippi"

# starting from the right side, all "i", "p", and "s" are removed:
print(word.rstrip("ips"))  # "M"

# the word starts with "M" rather than "i", "p", or "s", so no chars are removed from the left side:
print(word.lstrip("ips"))  # "Mississippi"

# "M", "i", "p", and "s" are removed from both sides, so nothing is left:
print(word.strip("Mips"))  # ""
```

Úselos con cuidado, o puede terminar con una cadena vacía.

## Resumen

En resumen, hemos considerado los principales métodos para cadenas. Aquí hay un breve resumen:

- Mientras trabaja con cadenas, debe recordar que las cadenas son **inmutables** , por lo tanto, todos los métodos que las "cambian" solo devuelven la copia de una cadena con los cambios necesarios.
- Si desea guardar el resultado de una llamada a un método para su uso posterior, debe asignar este resultado a una variable (ya sea la misma o la que tiene un nombre diferente).
- Si desea usar este resultado solo una vez, por ejemplo, en comparaciones o simplemente para imprimir la cadena formateada, puede usar el resultado en el lugar, como lo hicimos dentro `print()`.

| EJEMPLO                      | FUNCIÓN                                                      |
| ---------------------------- | ------------------------------------------------------------ |
| 'robot'.replace('o', '_', n) | Reemplaza n primeras apariciones de una subcadena antigua por una nueva. |
| "".replace("", 'robot')      | Inserta una subcadena en la línea vacía.                     |
| 'robot'.replace (' o ', "")  | Elimina subcadenas de la línea.                              |
| 'robot'.replace ("", "")     | Agrega espacio entre letras.                                 |

 

```python
name = input()

def normalize(new_name):

    # put your code here
    old_values = ["é", "ë", "á", "å", "œ", "æ"]
    new_values = ["e", "e", "a", "a", "oe", "ae"]
    for count, value in enumerate(old_values):
        new_name = new_name.replace(value, new_values[count])

    return new_name

print(normalize(name))


####
name = input()

def normalize(old_name):
    working_dict = {
        'é': 'e',
        'ë': 'e',
        'á': 'a',
        'å': 'a',
        'œ': 'oe',
        'æ': 'ae',
    }

    new_name = old_name
    for old_char, new_char in working_dict.items():
        new_name = new_name.replace(old_char, new_char)

    return new_name

print(normalize(name))
###
name = input()

def normalize():
    new_name = name.replace("é", "e").replace("ë", "e")
    new_name = new_name.replace("á", "a").replace("å", "a")
    new_name = new_name.replace("œ", "oe").replace("æ", "ae")
    # put your code here
    print(new_name)

normalize()
```



---



## ¿Qué es un Diccionario de datos?

Un Diccionario es una estructura de datos y un tipo de dato en Python con características especiales que nos permite almacenar cualquier tipo de valor como enteros, cadenas, listas e incluso otras funciones. Estos diccionarios nos permiten además identificar cada elemento por una clave (Key).

1. Para definir un diccionario, se encierra el listado de valores entre llaves. Las parejas de clave y valor se separan con comas, y la clave y el valor se separan con dos puntos.

    ```python
    diccionario = {'nombre' : 'Carlos', 'edad' : 22, 'cursos': ['Python','Django','JavaScript'] }
    ```

2. Podemos acceder al elemento de un Diccionario mediante la clave de este elemento, como veremos a continuación:

    ```python
    print diccionario['nombre'] #Carlos
    print diccionario['edad']#22
    print diccionario['cursos'] #['Python','Django','JavaScript']
    ```

3. También es posible insertar una lista dentro de un diccionario. Para acceder a cada uno de los cursos usamos los índices:

    ```python
    print diccionario['cursos'][0]#Python
    print diccionario['cursos'][1]#Django
    print diccionario['cursos'][2]#JavaScript
    ```

4. Para recorrer todo el Diccionario, podemos hacer uso de la estructura for:

    ```python
    for key in diccionario:
      print key, ":", diccionario[key]
    ```

## Métodos de los Diccionarios

- dict ()

    Recibe como parámetro una representación de un diccionario y si es factible, devuelve un diccionario de datos.

    ```python
    dic =  dict(nombre='nestor', apellido='Plasencia', edad=22)
    
    dic → {‘nombre’ : 'nestor', ‘apellido’ : 'Plasencia', ‘edad’ : 22}
    ```

- zip()

    Recibe como parámetro dos elementos iterables, ya sea una cadena, una lista o una tupla. Ambos parámetros deben tener el mismo número de elementos. Se devolverá un diccionario relacionando el elemento i-esimo de cada uno de los iterables.

    ```python
    dic = dict(zip('abcd',[1,2,3,4]))
    
    dic →   {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    ```

- items()

    Devuelve una lista de tuplas, cada tupla se compone de dos elementos: el primero será la clave y el segundo, su valor.

    ```python
    dic =   {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    items = dic.items()
    
    items → [(‘a’,1),(‘b’,2),(‘c’,3),(‘d’,4)]
    ```

- keys()

    Retorna una lista de elementos, los cuales serán las claves de nuestro diccionario.

    ```python
    dic =  {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    keys= dic.keys()
    
    keys→ [‘a’,’b’,’c’,’d’] 
    ```

- values()

    Retorna una lista de elementos, que serán los valores de nuestro diccionario.

    ```python
    dic =  {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    values= dic.values()
    
    values→ [1,2,3,4] 
    ```

- clear()

    Elimina todos los ítems del diccionario dejándolo vacío.

    ```python
    dic 1 =  {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    dic1.clean()
    
    dic1 → { }
    ```

- copy()

    Retorna una copia del diccionario original.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    dic1 = dic.copy()
    
    dic1 → {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    ```

- fromkeys()

    Recibe como parámetros un iterable y un valor, devolviendo un diccionario que contiene como claves los elementos del iterable con el mismo valor ingresado. Si el valor no es ingresado, devolverá none para todas las claves.

    ```python
    dic = dict.fromkeys(['a','b','c','d'],1)
    
    dic →  {‘a’ : 1, ’b’ : 1, ‘c’ : 1 , ‘d’ : 1}
    ```

- get()

    Recibe como parámetro una clave, devuelve el valor de la clave. Si no lo encuentra, devuelve un objeto none.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    valor = dic.get(‘b’) 
    
    valor → 2
    ```

- pop()

    Recibe como parámetro una clave, elimina esta y devuelve su valor. Si no lo encuentra, devuelve error.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    valor = dic.pop(‘b’) 
    
    valor → 2
    dic → {‘a’ : 1, ‘c’ : 3 , ‘d’ : 4}
    ```

- setdefault()

    Funciona de dos formas. En la primera como get

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    valor = dic.setdefault(‘a’)
    
    valor → 1
    ```

    Y en la segunda forma, nos sirve para agregar un nuevo elemento a nuestro diccionario.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    valor = dic.setdefault(‘e’,5)
    
    dic → {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4 , ‘e’ : 5}
    ```

- update()

    Recibe como parámetro otro diccionario. Si se tienen claves iguales, actualiza el valor de la clave repetida; si no hay claves iguales, este par clave-valor es agregado al diccionario.

    ```python
    dic 1 = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    dic 2 = {‘c’ : 6, ’b’ : 5, ‘e’ : 9 , ‘f’ : 10}
    dic1.update(dic 2)
    
    dic 1 → {‘a’ : 1, ’b’ : 5, ‘c’ : 6 , ‘d’ : 4 , ‘e’ : 9 , ‘f’ : 10}
    ```

Estos son algunos de los métodos más útiles y más utilizados en los Diccionarios. Python es un gran lenguaje de programación que nos permite programar de una manera realmente sencilla. Si deseas conocer mucho más y aprender a profundidad esta tecnología, ingresa al [Curso de Python](https://devcode.la/cursos/python/) que tenemos en Devcode. 

> https://devcode.la/tutoriales/diccionarios-en-python/

---

# Teoría: secuencias de escape

Recordemos los problemas que puede encontrar al utilizar la `print()`función.

A nadie le gusta escribir palabras largas, así que aquí viene el apóstrofe. Sin embargo, tenga cuidado, al usar un apóstrofo en cadenas en Python, es posible que obtenga un mensaje de error. Echemos un vistazo al siguiente ejemplo:

```python
# Bad example

warning = 'That's my car'
print(warning)
```

La oración parece verse bien, pero Python le mostrará un mensaje de error « `EOL while scanning string literal`». ¿Por qué ocurrió ese error? La abreviatura "EOL" significa "End-of-line" y significa que Python revisó el texto y no encontró el final de la cadena. La oración se dividió en dos partes. El primero es `"That"`y el segundo es `"s my car"`.

## ¿Qué es una secuencia de escape?

Para evitar el problema descrito, debe utilizar **secuencias de escape** .

Todas las secuencias de escape comienzan con una barra invertida `\`, que se interpreta como un **carácter de escape** . Una barra invertida indica que uno o más caracteres deben manejarse de una manera especial o que el siguiente carácter tiene un significado diferente.

Agregue un carácter de escape a nuestro ejemplo y vea que la cita ahora se interpreta como el símbolo literal de una sola cita sin errores.

```python
# Better example
 
warning = 'That\'s my car'
print(warning)  # That's my car
```



¡No olvide que las comillas simples y un apóstrofe en la misma oración son un mal estilo! Según PEP8, es mejor utilizar comillas dobles en estos casos.



Se puede usar una barra invertida en combinación con otro símbolo para hacer algunas cosas en particular. Por ejemplo, si usa `\b`en el medio de la cadena y luego intenta imprimirlo, no verá el carácter antes `\b`. La combinación `\b` significa un carácter de retroceso:

```python
print('deleted\b sign')  # delete sign
```

Eche un vistazo a otras secuencias de escape:

- `\n` - nueva línea
- `\t` - tabulación horizontal
- `\r`- mueve todos los caracteres posteriores `\r`al principio de la línea, sobrescribiendo tantos caracteres como movidos.

El uso de secuencias de escape en una cadena es siempre el mismo. No obstante, daremos más ejemplos en la siguiente sección.

Entonces, ¿qué pasa si necesita imprimir la barra invertida?

```python
print('\')  # SyntaxError: EOL while scanning string literal
```

El error ocurre porque Python espera una secuencia de escape que no está allí. En este caso, debemos utilizar una doble barra invertida.`\\`

```python
print('\\')  # \
```

Se agrega un extra `\`para decirle a Python que la próxima `\`debería **no** ser interpretado como el inicio de una secuencia de escape.

Ahora, si desea imprimir el texto que contiene `\`, puede duplicarlo. Por ejemplo, esto es útil cuando necesita imprimir literalmente `\n`, porque `print('\n')`solo generará una nueva línea en blanco. ¡La doble barra invertida te ayudará en tales situaciones!

```python
print('\\n')  # \n
```

Y también puedes escribir:

```python
metal = '\m/'
print(metal)  # \m/
```

¿Por qué todo es correcto en tal caso? Nuestra cadena se `\`imprimió correctamente, porque `\m`no es una expresión de escape. Por lo tanto, no se ha producido ningún formateo. Un ejemplo más:

```python
face = '\^_^/'
print(face)  # \^_^/
```

La función `repr()`devuelve una representación imprimible de esta cadena, por lo que las secuencias de escape son visibles.

```python
print(repr(face))  # '\\^_^/'
```

Cuando queremos saber la longitud de una cadena, también se tienen en cuenta las secuencias de escape:

```python
print(len(repr(face)))  # 8
```

## Otros ejemplos

Consideremos un ejemplo con la secuencia de escape `\n`:

```python
# The new lineprint('Hello \nWorld!')
```

La `\n `combinación comienza una nueva línea, por lo que verá el siguiente resultado:

```no-highlight
HelloWorld!
```

El siguiente ejemplo muestra la secuencia de escape `\t`. Como se dijo anteriormente, `\t` se utiliza para la tabulación. Si lo coloca en el medio de una cadena, las dos partes de la cadena se dividirán por un espacio en blanco que se llama tabulación. Es muy útil cuando trabaja con un texto.

```python
# The tabulationprint('Hello\tWorld!')  # Hello   World!
```

Otra secuencia de escape que puede resultar útil mientras trabaja con texto es `\r`. El nombre común de esta secuencia de escape es retorno de carro. Mueve los caracteres después `\r`al principio de la línea, reemplazando el número exacto de caracteres antiguos. Es decir, si la longitud de la cadena es más larga antes de esta secuencia de escape, solo se reescribe el número requerido de caracteres.

```python
# The characters removal print("Hello, dear \rWorld!")  # World! dear
```

¡Tenga en cuenta que la longitud de la cuerda sigue siendo la misma!

```python
print(len("Hello, dear \rWorld!"))  # 19
```

Las secuencias de escape son fáciles de usar, ¿no? Hablemos más sobre la longitud de las cuerdas. Por ejemplo:

```python
# Comparing the lengthsgreeting = 'Hello, John'nice_greeting = 'Hello, \nJohn'print(greeting)# Hello, Johnprint(nice_greeting)# Hello, # Johnprint(len(greeting))       # 11print(len(nice_greeting))  # 12
```

Después de llamar a la `len()`función, podemos ver que la longitud de la cadena con una secuencia de escape (en este caso `\n`) es mayor.

Tenga cuidado al trabajar con cadenas porque la función `print()`no muestra secuencias de escape.

## Resumen

Por lo tanto, en este tema, hemos introducido secuencias de escape básicas, sus características y hemos considerado varios ejemplos de cómo usarlas, ¡así que ahora puede trabajar con ellas en cadenas de Python!



# Teoría: recibir información

A veces, los programas necesitan interactuar con los usuarios, ya sea para recibir algunos datos o para entregar algún tipo de resultado. Y ahí es cuando la `input()` función se roba el show.

## Leer la entrada de un usuario

Los datos de entrada que queremos obtener no son más que un valor introducido por el usuario. La `input()`función lee este valor y lo devuelve en un programa como una cadena. Por ejemplo, el siguiente programa lee el nombre de usuario e imprime un saludo.

```python
user_name = input()print('Hello, ' + user_name)
```

En la primera línea, el programa esperará a que el usuario ingrese algo como entrada, que asignaremos a una variable para que podamos usarla más tarde. En la segunda línea, el programa agrega el nombre ingresado al final de la `'Hello, '`cadena e imprime la frase completa como resultado.

Si un usuario ingresa `Sauron`, este programa imprime:

```python
Hello, Sauron
```

Entonces, su programa imprime un resultado que depende de la entrada del usuario (nombre).

## Mensajes claros

Es muy recomendable indicar claramente qué tipo de información esperamos de nuestro usuario. Para hacerlo, la `input()`función puede tomar un argumento opcional, que es un mensaje:

```python
user_name = input('Please, enter your name: ')print('Hello, ' + user_name)
```

El programa se inicia, el usuario ve el mensaje, ingresa su nombre y obtiene el resultado de la siguiente manera:

```no-highlight
Please, enter your name: SauronHello, Sauron
```

Otra forma de hacer esto es imprimir el mensaje por separado:

```python
print('Enter your name: ')user_name = input()print('Hello, ' + user_name)
```

En realidad, no hay una gran diferencia: en el ejemplo anterior, la entrada se imprimirá en la misma línea que el mensaje, mientras que en este caso se escribirá en la siguiente línea. Entonces, puedes elegir lo que quieras.



Aunque se recomienda imprimir mensajes para los usuarios, evítelos en nuestros desafíos de programación educativa, de lo contrario su código puede no pasar nuestras pruebas.



## Detalles importantes

Profundicemos en algunos detalles. En primer lugar, ¿cuánto tiempo puede durar la entrada del usuario? La segunda pregunta es: ¿cómo entiende el programa que la persona ingresó todo lo que quería?

Aquí hay algo sobre la `input()`función: tan pronto como el programa ha comenzado a ejecutar esta función, se detiene y espera a que el usuario ingrese algún valor y **presione Enter** . Eso también significa que si no hay información del usuario, el programa no se ejecutará más.

¿Qué más deberías recordar? Bueno, esto: cualquier valor que ingrese, la función lo verá como una **cadena** . No importa si ingresa dígitos o letras, la entrada se convertirá en una cadena.

Si desea que un número sea un **número** , debe escribirlo explícitamente:

```python
print("What's your favorite number?")value = int(input())  # now value keeps an integer number
```

Sin embargo, tenga cuidado: en estas circunstancias, si un usuario ingresa un valor no entero, `Error`aparecerá un.

Para leer varias entradas, debe llamar a la función más de una vez:

```python
day = int(input())  # 4month = input()     # October
```

¡Brillante! ¿Por qué esta fecha? Es simple:

```python
print('Cinnamon roll day is celebrated on', month, day)# Cinnamon roll day is celebrated on October 4
```

## Conclusión

Enhorabuena, ahora sabes cómo trabajar con `input()`, es decir, una función que te ayuda a interactuar con el usuario. Créanos, esto es algo que definitivamente apreciará al programar.

# Theory: String formatting

Hay ciertas situaciones en las que desea hacer que sus cadenas de texto sean algo "dinámicas", es decir, hacer que cambien dependiendo del valor de una variable o expresión. Por ejemplo, desea solicitarle al usuario su nombre e imprimirle el saludo con el nombre que ingresó. Pero, ¿cómo se puede incrustar una variable en una cadena? Si lo hace de la forma más intuitiva, se sentirá decepcionado:

```python
a = input()print('Hello, a')
```

La salida será:

```python
Hello, a
```

Afortunadamente, Python ofrece una gran variedad de métodos para formatear la salida de la manera que desee y nos concentraremos en los dos principales:

- Literales de cadena formateados
- El `str.format()`metodo

Anteriormente, **el operador%** estaba en uso. Este operador integrado se derivó del lenguaje C y se usó en algunas situaciones de la siguiente manera:

**valor de cadena**

Por lo tanto, la variable a la derecha de `%`se incluyó en la cadena a la izquierda. Si quisiéramos dividir 11 entre 3, el `/`operador habría devuelto un número flotante con muchos lugares decimales.

```python
print(11 / 3)  # 3.6666666666666665
```

Con `%`carácter, podríamos controlar el número de posiciones decimales, por ejemplo, reducir su número a 3 o 2:

```python
print('%.3f' % (11/3))  # 3.667print('%.2f' % (11/3))  # 3.67print(round((11/3), 3)) # 3.667
```

Para cada operación, tenía que conocer muchos especificadores, modificadores de longitud y tipos de conversión. Una gran variedad de operadores adicionales condujo a algunos errores comunes. Es por eso que se introdujeron operadores más modernos y fáciles de usar. El progreso nunca se detiene, ¡lo sabes!

Dar formato a sus cadenas también hace que su código se vea más legible y fácilmente editable.

Siguiente sección ![img](https://hyperskill.azureedge.net/static/img/back-white.02e4bb70.svg)



## El str. método format ()

El funcionamiento del método ya está descrito en su nombre: en la **parte de cadena** , introducimos llaves como marcadores de posición para las variables enlistadas en la **parte de formato** :

```python
print('Mix {}, {} and a {} to make an ideal omelet.'.format('2 eggs', '30 g of milk', 'pinch of salt'))
```

Las expresiones se colocan en lugar de llaves en el orden en que se mencionaron:

```no-highlight
Mix 2 eggs, 30 g of milk and a pinch of salt to make an ideal omelet.
```

Puede usar la misma variable en una cadena más de una vez si es necesario. Además, puede abordar los objetos haciendo referencia a sus **posiciones** entre llaves (como de costumbre, *la numeración comienza desde cero* ). Atención: el orden que elijas puede ser muy importante. Los siguientes dos códigos:

```python
print('{0} in the {1} by Frank Sinatra'.format('Strangers', 'Night'))
```

y

```python
print('{1} in the {0} by Frank Sinatra'.format('Strangers', 'Night'))
```

tendrá diferentes salidas:

```no-highlight
Strangers in the Night by Frank SinatraNight in the Strangers by Frank Sinatra
```

La segunda salida suena realmente extraña, ¿no?

Si ha mencionado más variables de las necesarias en la parte de formato, las adicionales simplemente se ignorarán.

También podemos usar palabras clave para hacer que dichas cadenas sean más legibles. ¡No olvides que puedes romper las líneas fácilmente! Por ejemplo:

```python
print('The {film} at {theatre} was {adjective}!'.format(film='Lord of the Rings',                                                        adjective='incredible',                                                        theatre='BFI IMAX'))
```

Tenga en cuenta que también puede mezclar el orden como desee si usa palabras clave. Aquí está la cadena formateada:

```no-highlight
The Lord of the Rings at BFI IMAX was incredible!
```

Además, puede combinar argumentos posicionales y de palabras clave:

```python
print('The {0} was {adjective}!'.format('Lord of the Rings', adjective='incredible'))# The Lord of the Rings was incredible!
```

Sin embargo, controle el orden de sus argumentos:

```python
print('The {0} was {adjective}!'.format(adjective='incredible', 'Lord of the Rings'))# SyntaxError: positional argument follows keyword argument
```

El último fragmento de código resultó en `SyntaxError`, ya que los argumentos posicionales deben mencionarse primero.



Recuerde, como regla de Python, que los argumentos de palabras clave siempre se escriben **después de** argumentos posicionales o que no son palabras clave.



## Literales de cadena formateados

**Los literales de cadena formateados** (o, simplemente, **cadenas f** ) se utilizan para incrustar los valores de las expresiones dentro de los literales de cadena. Se supone que esta forma es la más fácil: solo necesita poner **f** antes de la cadena y poner las variables que desea incrustar en la cadena entre llaves. También son la característica más nueva entre todos los métodos de formato de cadenas en Python.

```python
name = 'Elizabeth II'title = 'Queen of the United Kingdom and the other Commonwealth realms'reign = 'the longest-lived and longest-reigning British monarch'f'{name}, the {title}, is {reign}.'
```

Si imprime esta cadena corta, verá una salida que es cinco veces más larga que su representación en el código:

```no-highlight
Elizabeth II, the Queen of the United Kingdom and the other Commonwealth realms, is the longest-lived and longest-reigning British monarch.
```

También puede usar diferentes especificaciones de formato con f-literales, por ejemplo, el redondeo de decimales se vería así:

```python
hundred_percent_number = 1823needed_percent = 16needed_percent_number = hundred_percent_number * needed_percent / 100print(f'{needed_percent}% from {hundred_percent_number} is {needed_percent_number}')# 16% from 1823 is 291.68print(f'Rounding {needed_percent_number} to 1 decimal place is {needed_percent_number:.1f}')# Rounding 291.68 to 1 decimal place is 291.7
```

Puede leer más sobre el mini-lenguaje de especificación de formato en Python en la [documentación oficial](https://docs.python.org/3.6/library/string.html#format-specification-mini-language) .

## Resumen

Por lo tanto, en este tema, hemos aprendido varias formas de formatear cadenas: usando% operator, método str.format () y f-strings. Quizás ahora piense que estos métodos no son importantes y están sobrevalorados, pero en la práctica, son bastante útiles y le brindan la oportunidad de hacer que su código se vea elegante y legible.



# Teoría: Programa con números

Los programas en los que no hay nada que calcular son bastante raros. Por lo tanto, aprender a programar con números nunca es una mala idea. Una habilidad aún más valiosa que estamos a punto de aprender es el procesamiento de los datos del usuario. Con su ayuda, puede crear aplicaciones interactivas y mucho más flexibles. ¡Entonces empecemos!

## Leer números de la entrada del usuario

Dado que se ha familiarizado con la `input()`función en Python, no es nuevo para usted que cualquier dato que se pase a esta función se trate como una **cadena** . Pero, ¿cómo debemos lidiar con los valores numéricos? Como regla general, se convierten explícitamente a los tipos numéricos correspondientes:

```python
integer = int(input())floating_point = float(input())
```

Preste atención a las mejores prácticas actuales: es crucial no nombrar sus variables como tipos integrados (por ejemplo, **float** o **int** ). Además, debemos tener en cuenta los errores del usuario: si un usuario escribe una entrada inexacta, digamos, una cadena 'dos'en lugar de un número 2, `ValueError`ocurrirá una. Por el momento, no nos centraremos en eso; pero no se preocupe, hay más información disponible sobre errores en un tema específico. Ahora, considere un ejemplo más detallado y pragmático de manejo de entradas numéricas.

## Millas aéreas gratuitas

Imagine que tiene una tarjeta de crédito con un programa de bonificación de millas aéreas gratis (o tal vez ya tenga una). Como usuario, se espera que ingrese la cantidad de dinero que gasta en promedio con esta tarjeta por mes. Supongamos que el programa de bonificación le otorga 2 millas aéreas gratuitas por cada dólar que gasta. Aquí hay un programa simple para descubrir cuándo puede viajar a algún lugar gratis:

```python
# the average amount of money per monthmoney = int(input("How much money do you spend per month: "))# the number of miles per unit of moneyn_miles = 2# earned milesmiles_per_month = money * n_miles# the distance between London and Parisdistance = 215# how many months do you need to get# a free trip from London to Paris and backprint(distance * 2 / miles_per_month)
```

Este programa calculará cuántos meses se necesitan para recorrer la distancia seleccionada y regresar.



Aunque se recomienda escribir mensajes para los usuarios en la `input()`función, evítelos en nuestros desafíos de programación educativa, de lo contrario su código puede no pasar nuestras pruebas.



## Formas avanzadas de asignación

Siempre que usa un signo igual `=`, en realidad asigna algún valor a un nombre. Por esa razón, `=`normalmente se lo denomina **operador de asignación** . Mientras tanto, hay otros operadores de asignación que puede usar en Python. También se denominan **operadores de asignación compuesta** , ya que realizan una operación aritmética y una asignación en un solo paso. Eche un vistazo al fragmento de código a continuación:

```python
# simple assignmentnumber = 10number = number + 1  # 11
```

Este código es equivalente al siguiente:

```python
# compound assignmentnumber = 10number += 1  # 11
```

Uno puede ver claramente en el ejemplo que la segunda parte del código es más concisa (ya que no repite el nombre de la variable).

Naturalmente, existen formas de asignación similares para el resto de operaciones aritméticas: `-=`, `*=`, `/=`, `//=`, `%=`, `**=`. Dada la oportunidad, úsalas para ahorrar tiempo y esfuerzo.

A continuación se presenta una posible aplicación de la asignación compuesta.

## Variable de contador

En programación, los bucles se utilizan junto con variables especiales llamadas **contadores** . Un **contador** cuenta cuántas veces se ejecuta un código en particular. También se deduce que los contadores deben ser números enteros. Ahora vamos al grano: puede usar los operadores `+=`y `-=`para aumentar o disminuir el contador respectivamente.

Considere este ejemplo donde un usuario determina el valor por el cual se incrementa el contador:

```python
counter = 1step = int(input())  # let it be 3counter += stepprint(counter)  # it should be 4
```

En caso de que solo necesite números enteros no negativos del usuario (¡después de todo, estamos aumentando el contador!), Puede evitar entradas incorrectas utilizando la `abs()`función. Es una función incorporada de Python que devuelve el valor absoluto de un número (es decir, el valor independientemente de su signo). Reajustemos un poco nuestro último programa:

```python
counter = 1step = abs(int(input()))  # user types -3counter += stepprint(counter)  # it's still 4
```

Como puede ver, gracias a la `abs()`función obtuvimos un número positivo.



Por ahora, está bien que no sepa mucho sobre los detalles mencionados de **errores** , **bucles** y **funciones integradas** en Python. Nos pondremos al día y nos aseguraremos de que conozca estos temas de manera integral. ¡Seguir aprendiendo!



## Conclusión

Por lo tanto, hemos arrojado algo de luz sobre nuevos detalles sobre la aritmética de enteros y el procesamiento de entradas numéricas en Python. No dude en utilizarlos en sus proyectos futuros.



# Teoría: Lista

En sus programas, a menudo necesita agrupar varios elementos para procesarlos como un solo objeto. Para ello, necesitará utilizar diferentes colecciones. Una de las colecciones más útiles de Python es una **lista** . Es una de las cosas más importantes de Python.

## Crear e imprimir listas

Mire una lista simple que almacena varios nombres de razas de perros:

```python
dog_breeds = ['corgi', 'labrador', 'poodle', 'jack russell']print(dog_breeds)  # ['corgi', 'labrador', 'poodle', 'jack russell']
```

En la primera línea, usamos corchetes para crear una lista que contiene cuatro elementos y luego la asignamos a la `dog_breeds`variable. En la segunda línea, la lista se imprime a través del nombre de la variable. Todos los elementos se imprimen en el mismo orden en que se almacenaron en la lista porque las listas están **ordenadas** .

Aquí hay otra lista que contiene cinco números enteros:

```python
numbers = [1, 2, 3, 4, 5]print(numbers)  # [1, 2, 3, 4, 5]
```

Otra forma de crear una lista es invocar la `list`función. Se utiliza para crear una lista a partir de un objeto **iterable** : es decir, un tipo de objeto en el que puede obtener sus elementos uno por uno. El concepto de iterabilidad se explicará en detalle más adelante, pero veamos los ejemplos a continuación:

```python
list_out_of_string = list('danger!')print(list_out_of_string)  # ['d', 'a', 'n', 'g', 'e', 'r', '!']list_out_of_integer = list(235)  # TypeError: 'int' object is not iterable
```

Entonces, la `list`función crea una lista que contiene cada elemento del objeto iterable dado. Por ahora, recuerde que una **cadena** es un ejemplo de un objeto **iterable** y un **número entero** es un ejemplo de un objeto **no iterable** . Una **lista en** sí misma también es un objeto **iterable** .

Notemos también la diferencia entre la `list`función y la creación de una lista usando corchetes:

```python
multi_element_list = list('danger!')print(multi_element_list)  # ['d', 'a', 'n', 'g', 'e', 'r', '!']single_element_list = ['danger!']print(single_element_list)  # ['danger!']
```

Los corchetes y la `list`función también se pueden utilizar para crear **listas vacías** que no tienen ningún elemento.

```python
empty_list_1 = list()empty_list_2 = []
```

En los siguientes temas, consideraremos cómo llenar listas vacías.

## Características de las listas

Las listas pueden almacenar **valores duplicados** tantas veces como sea necesario.

```python
on_off_list = ['on', 'off', 'on', 'off', 'on']print(on_off_list)  # ['on', 'off', 'on', 'off', 'on']
```

Otro aspecto importante de las listas es que pueden contener **diferentes tipos** de elementos. Por lo tanto, no hay restricciones ni tipos de lista fijos, y puede agregar a su lista cualquier dato que desee, como en el siguiente ejemplo:

```python
different_objects = ['a', 1, 'b', 2]
```

## Longitud de una lista

A veces es necesario saber cuántos elementos hay en una lista. Hay una función incorporada llamada `len`que se puede aplicar a cualquier objeto **iterable** y devuelve simplemente la **longitud** de ese objeto.

Entonces, cuando se aplica a una lista, devuelve el número de elementos en esa lista.

```python
numbers = [1, 2, 3, 4, 5]print(len(numbers))  # 5empty_list = list()print(len(empty_list))  # 0single_element_list = ['danger!']print(len(single_element_list))  # 1multi_elements_list = list('danger!')print(len(multi_elements_list))  # 7
```

En el ejemplo anterior, puede ver cómo `len()`funciona la función. Nuevamente, preste atención a la diferencia entre `list()`y `[]`según se aplica a las cadenas: es posible que no resulte en lo que esperaba.

## Resumen

Como resumen, observamos que las listas son:

- **ordenado** , es decir, cada elemento tiene una posición fija en una lista;
- **iterable** , es decir, puede obtener sus elementos uno por uno;
- capaz de almacenar **valores duplicados** ;
- capaz de almacenar **diferentes tipos de elementos** .

# Teoría: índices

Hay varios tipos de colecciones para almacenar datos en Python. Las colecciones de elementos ordenados posicionalmente se suelen denominar **secuencias** , y tanto las listas como las cadenas les pertenecen. Cada elemento de una lista, así como cada carácter de una cadena, tiene un **índice** que corresponde a su posición. Los índices se utilizan para acceder a elementos dentro de una secuencia. La indexación se *basa en cero* , por lo que si ve a una persona que cuenta desde cero, debe haber conocido a un programador.

## Índices de elementos

Para acceder a un elemento de una lista por su índice, debe utilizar **corchetes.** Agrega los corchetes después de la lista y, entre ellos, escribe el índice de un elemento que desea obtener.

No se olvide **,** los índices comienzan en 0, por lo que el índice del primer elemento es 0. El índice del último elemento es igual `len(list) - 1`.

Echemos un vistazo al siguiente ejemplo:

```python
colors = ['red', 'green', 'blue']first_elem = colors[0]   # 'red'second_elem = colors[1]  # 'green'third_elem = colors[2]   # 'blue'
```

Las cadenas funcionan de la misma manera:

```python
pet = "cat"first_char = pet[0]   # 'c'second_char = pet[1]  # 'a'third_char = pet[2]   # 't'
```

## Peligros potenciales

Al usar índices, es importante mantenerse dentro del rango de su secuencia: obtendrá un error (llamado `IndexError`) si intenta acceder a un elemento con un índice no existente.

```python
colors = ['red', 'green', 'blue']pet = "cat"print(colors[3])  # IndexError: list index out of rangeprint(pet[3])     # IndexError: string index out of range
```

Hay un obstáculo más en tu camino. Imagina que quieres cambiar uno de los elementos de una lista. Se puede hacer fácilmente:

```python
colors = ['red', 'green', 'blue']colors[1] = 'white'print(colors)  # ['red', 'white', 'blue']
```

Sin embargo, cuando se trata de cadenas, dicha reasignación es imposible. Las cadenas, a diferencia de las listas, son inmutables, por lo que no puede modificar su contenido con índices:

```python
pet = "cat"pet[0] = "b"# TypeError: 'str' object does not support item assignment
```

No se preocupe, después de un poco de práctica, no encontrará estos errores.

## Índices negativos

La forma más fácil de acceder a los elementos al final de una lista o una cadena es usar **índices negativos** : el menos antes del número cambia tu perspectiva de alguna manera y miras la secuencia desde el final. Entonces, el último elemento de una lista, en este caso, tiene el índice igual a **-1** , y el primer elemento de la lista tiene el índice `-len(list)`(la longitud de la lista).

Por ejemplo:

```python
colors = ['red', 'green', 'blue']last_elem = colors[-1]    # 'blue'second_elem = colors[-2]  # 'green'first_elem = colors[-3]   # 'red'pet = "cat"last_char = pet[-1]    # 't'second_char = pet[-2]  # 'a'first_char = pet[-3]   # 'c'
```

Como puede ver, funciona igual para listas y cadenas.

Si escribe un índice negativo no existente, también obtendrá `IndexError`. Tenga cuidado con los índices para evitar errores uno por uno en su código.

La siguiente imagen muestra el concepto general de índices en una lista:

[![img](https://camo.githubusercontent.com/d4db783d6654d3460374edd051f05512ae7cb36c88cadf10b95e29c3b254367f/68747470733a2f2f756361726563646e2e636f6d2f35343835663339372d386132662d343237392d623533342d6134393666653530393436392f)](https://camo.githubusercontent.com/d4db783d6654d3460374edd051f05512ae7cb36c88cadf10b95e29c3b254367f/68747470733a2f2f756361726563646e2e636f6d2f35343835663339372d386132662d343237392d623533342d6134393666653530393436392f)

## Resumen

En este tema, hemos aprendido qué son los índices positivos y negativos en Python, cómo encontrar elementos en una lista por sus índices y qué errores pueden ocurrir al usarlos. Dado que ha aprendido el concepto de índices, esperamos que a partir de ahora no encuentre dificultades al utilizarlos.

# Teoría: invocar una función

Aunque invocar funciones en Python no se trata de lanzar un hechizo o algo parecido, a veces funciona de maravilla. Empecemos por el concepto. Básicamente, una **función** es un fragmento estructurado de código que podemos querer usar en más de un lugar y más de una vez. Por otro lado, las funciones nos permiten leer mucho mejor tanto nuestro código como el de otra persona. ¿Aún no se han convertido en tus favoritos?

Aquí hay una llamada de función simple:

```python
multiply(1, 7)
```

Aquí `multiply`está el nombre de la función y los números entre paréntesis `(1, 7)`son sus **argumentos** . ¿Qué es un argumento? Bueno, es solo un valor, que se usará dentro del cuerpo de la función. ¡Vamos a profundizar más en ello!

## Invocando print ()

Para **llamar** , o **invocar** , **una función** en su programa, simplemente escriba su nombre y agregue paréntesis después. ¡Eso es todo lo que se necesita! Dato curioso: si alguna vez ha escrito una expresión como esta `print("Hello, world!")`, ya sabe un poco sobre funciones. En este pequeño ejemplo, sin embargo, vemos el mensaje"¡Hola Mundo!"entre paréntesis después del nombre de la `print`función. ¿Qué significa? Esta cadena es solo un argumento. Y la mayoría de las veces, las funciones tienen argumentos. En cuanto a la `print`función, también podemos usarla sin ningún argumento o incluso con múltiples argumentos:

```python
print("Hello, world!")print()print("Bye,", "then!")
```

Y aquí está la salida:

```python
Hello, world!Bye, then!
```

Entonces, la primera llamada imprime una cadena, la segunda llamada `print`sin argumentos imprime, de hecho, una línea vacía y la última llamada genera nuestros dos mensajes como una expresión. ¿Le sorprenden estos resultados? Luego, puede aprender cómo `print`funciona la función con más detalle en su [documentación](https://docs.python.org/3/library/functions.html#print) . La documentación de Python contiene todo tipo de información sobre la función de su interés, por ejemplo, qué argumentos espera.

## Funciones integradas

Las funciones pueden hacer la vida más fácil, siempre que uno sea consciente de su existencia. Muchos algoritmos ya están escritos, por lo que no es necesario reinventarlos, excepto quizás con fines educativos. El intérprete de Python tiene una serie de funciones y tipos **integrados** , por lo que siempre están disponibles. Actualmente, el número de [funciones integradas asciende a 69](https://docs.python.org/3/library/functions.html) (en la última versión **Python 3.8** ). Algunos de ellos se utilizan para convertir el **tipo de objeto** , por ejemplo, `str()`devuelve una cadena, `int()`devuelve un entero, `float()`devuelve un número de punto flotante. Otros se ocupan de los **números** : puedes `round()`ellos y `sum()`ellos, encuentra el mínimo `min()`o el máximo`max()`. Otros más nos dan información sobre el objeto: su `type()`longitud `len()`. ¡Considérelos en acción!

En el siguiente ejemplo, `len()`cuenta el número de caracteres de la cadena (lo mismo ocurre con cualquier **secuencia** ).

```python
number = "111"# finding the length of an objectprint(len(number))  # 3
```

Luego declaramos las variables `integer`y `float_number`y escribir su suma en `my_sum`. Por cierto, la `sum()`función también se ocupa de secuencias.

```python
# converting typesinteger = int(number)float_number = float(number)print(str(float_number))  # "111.0"# adding and rounding numbersmy_sum = sum((integer, float_number))
```

El resultado es un número de punto flotante, que se aclara después de la impresión `my_sum`.

```python
print(my_sum)  # 222.0print(round(my_sum))  # 222
```

Además, puede ver cómo encontrar los valores mínimo y máximo: el número más pequeño es igual a 111 y el mayor numero 222.0 pertenece a los flotadores.

```python
# finding the minimum and the maximumprint(min(integer, float_number))  # 111print(type(max(integer, float_number, my_sum)))  # <class 'float'>
```

Hay mucho más por explorar, pero resumámoslo.

```python
jack_age = int(input())alex_age = int(input())lana_age = int(input())print(min(jack_age, alex_age, lana_age))
```



## Resumen

La belleza de las funciones es que podemos usarlas sin tener una idea clara de su estructura interna y cómo se las arreglan para realizar lo que necesitamos. Pero si desea darle un buen uso a una función, asegúrese de verificar su documentación o intente invocar la función especial `help()`con el nombre de la función en cuestión entre paréntesis. Puede ser necesario si, por ejemplo, la función no devuelve ningún valor, escribe los datos procesados en un archivo o imprime la salida en la pantalla.

Hagamos un breve resumen:

- Las funciones están destinadas a ser reutilizables, lo que significa que podemos aplicarlas varias veces con diferentes argumentos,
- para llamar a una función escriba su nombre seguido de paréntesis y coloque los argumentos dentro,
- normalmente, una función tiene documentación, lo que a veces puede ser de gran ayuda.





# Teoría: invocar una función

Aunque invocar funciones en Python no se trata de lanzar un hechizo o algo parecido, a veces funciona de maravilla. Empecemos por el concepto. Básicamente, una **función** es un fragmento estructurado de código que podemos querer usar en más de un lugar y más de una vez. Por otro lado, las funciones nos permiten leer mucho mejor tanto nuestro código como el de otra persona. ¿Aún no se han convertido en tus favoritos?

Aquí hay una llamada de función simple:

```python
multiply(1, 7)
```

Aquí `multiply`está el nombre de la función y los números entre paréntesis `(1, 7)`son sus **argumentos** . ¿Qué es un argumento? Bueno, es solo un valor, que se usará dentro del cuerpo de la función. ¡Vamos a profundizar más en ello!

## Invocando print ()

Para **llamar** , o **invocar** , **una función** en su programa, simplemente escriba su nombre y agregue paréntesis después. ¡Eso es todo lo que se necesita! Dato curioso: si alguna vez ha escrito una expresión como esta `print("Hello, world!")`, ya sabe un poco sobre funciones. En este pequeño ejemplo, sin embargo, vemos el mensaje"¡Hola Mundo!"entre paréntesis después del nombre de la `print`función. ¿Qué significa? Esta cadena es solo un argumento. Y la mayoría de las veces, las funciones tienen argumentos. En cuanto a la `print`función, también podemos usarla sin ningún argumento o incluso con múltiples argumentos:

```python
print("Hello, world!")print()print("Bye,", "then!")
```

Y aquí está la salida:

```python
Hello, world!Bye, then!
```

Entonces, la primera llamada imprime una cadena, la segunda llamada `print`sin argumentos imprime, de hecho, una línea vacía y la última llamada genera nuestros dos mensajes como una expresión. ¿Le sorprenden estos resultados? Luego, puede aprender cómo `print`funciona la función con más detalle en su [documentación](https://docs.python.org/3/library/functions.html#print) . La documentación de Python contiene todo tipo de información sobre la función de su interés, por ejemplo, qué argumentos espera.

## Funciones integradas

Las funciones pueden hacer la vida más fácil, siempre que uno sea consciente de su existencia. Muchos algoritmos ya están escritos, por lo que no es necesario reinventarlos, excepto quizás con fines educativos. El intérprete de Python tiene una serie de funciones y tipos **integrados** , por lo que siempre están disponibles. Actualmente, el número de [funciones integradas asciende a 69](https://docs.python.org/3/library/functions.html) (en la última versión **Python 3.8** ). Algunos de ellos se utilizan para convertir el **tipo de objeto** , por ejemplo, `str()`devuelve una cadena, `int()`devuelve un entero, `float()`devuelve un número de punto flotante. Otros se ocupan de los **números** : puedes `round()`ellos y `sum()`ellos, encuentra el mínimo `min()`o el máximo`max()`. Otros más nos dan información sobre el objeto: su `type()`longitud `len()`. ¡Considérelos en acción!

En el siguiente ejemplo, `len()`cuenta el número de caracteres de la cadena (lo mismo ocurre con cualquier **secuencia** ).

```python
number = "111"# finding the length of an objectprint(len(number))  # 3
```

Luego declaramos las variables `integer`y `float_number`y escribir su suma en `my_sum`. Por cierto, la `sum()`función también se ocupa de secuencias.

```python
# converting typesinteger = int(number)float_number = float(number)print(str(float_number))  # "111.0"# adding and rounding numbersmy_sum = sum((integer, float_number))
```

El resultado es un número de punto flotante, que se aclara después de la impresión `my_sum`.

```python
print(my_sum)  # 222.0print(round(my_sum))  # 222
```

Además, puede ver cómo encontrar los valores mínimo y máximo: el número más pequeño es igual a 111 y el mayor numero 222.0 pertenece a los flotadores.

```python
# finding the minimum and the maximumprint(min(integer, float_number))  # 111print(type(max(integer, float_number, my_sum)))  # <class 'float'>
```

Hay mucho más por explorar, pero resumámoslo.

## Resumen

La belleza de las funciones es que podemos usarlas sin tener una idea clara de su estructura interna y cómo se las arreglan para realizar lo que necesitamos. Pero si desea darle un buen uso a una función, asegúrese de verificar su documentación o intente invocar la función especial `help()`con el nombre de la función en cuestión entre paréntesis. Puede ser necesario si, por ejemplo, la función no devuelve ningún valor, escribe los datos procesados en un archivo o imprime la salida en la pantalla.

Hagamos un breve resumen:

- Las funciones están destinadas a ser reutilizables, lo que significa que podemos aplicarlas varias veces con diferentes argumentos,
- para llamar a una función escriba su nombre seguido de paréntesis y coloque los argumentos dentro,
- normalmente, una función tiene documentación, lo que a veces puede ser de gran ayuda.

```python
x = int(input())y = int(input())print(sum([x], y))
```

> Un dato curioso sobre `min()`y `max()`es que estas funciones pueden ayudarlo a ordenar en orden alfabético. Si se pasa una cadena como argumento, `min()`devolverá la primera letra (alfabéticamente) y `max()`la última (algo zetabéticamente). Y si especifica más de un valor, `min()`devolverá la primera cadena en orden alfabético y `max()`, en cambio, la última. Por ejemplo, `min("alpha", "omega")`te da `"alpha"`, mientras que `max("alpha", "omega")`devuelve `"omega"`.

# Teoría: declarar una función

A menudo, las funciones integradas no son suficientes ni siquiera para los principiantes. En tal caso, no hay más remedio que crear su propia función usando la palabra clave `def`(derecha, derivada de **definir** ). Echemos un vistazo a la sintaxis:

```python
def function_name(parameter1, parameter2, ...):    # function's body    ...    return "return value"
```

Después `def`, escribimos el nombre de nuestra función (para poder invocarla más tarde) y los nombres de los **parámetros** , que nuestra función puede aceptar, entre paréntesis. No se pierda los dos puntos al final de la línea. Los nombres de una función y sus parámetros siguen la misma convención que los **nombres de las variables** , es decir, deben escribirse en **minúsculas con guiones bajos entre las palabras** .

Una sangría de 4 espacios muestra al intérprete dónde comienza y dónde termina el cuerpo de la función. Todas las declaraciones del cuerpo de la función deben tener sangría. Puede hacer cálculos dentro de su función y usar la `return`palabra clave para devolver el resultado. Solo cuando no hay sangría, finaliza la definición de la función.

Posteriormente, los parámetros toman valores pasados en una llamada de función. Los valores que pasamos a una función se conocen como **argumentos** . La única distinción entre parámetros y argumentos es que introducimos parámetros en una definición de función y damos argumentos (algunos valores específicos) en una llamada de función. Aquí hay un ejemplo un poco menos abstracto de una función:

```python
# Function definitiondef multiply(x, y):    return x * y# Function callsa = multiply(3, 5)   # 15b = multiply(a, 10)  # 150
```

En caso de que no desee pasar ningún argumento, los corchetes permanecen vacíos:

```python
def welcome():    print("Hello, people!")
```

También puede declarar una especie de función vacía con la `pass`declaración:

```python
# This function does nothing (yet)def lazy_func(param):    pass
```

Cuando elige llamar `lazy_func()`con un valor arbitrario como argumento, no sucederá nada. Entonces `pass`es solo un marcador de posición, pero al menos su código será válido con él.

```python
# CALCULADORAdef suma(x, y):    return x + ydef resta(x, y):    return x - ydef multi(x, y):    return x * ydef div(x, y):    return x / ydef main():    opc = input('opc:  ')    x = int(input('x:  '))    y = int(input('y:  '))    if opc == 'a':        a = suma(x, y)        print(a)    elif opc == 'b':        a = resta(x, y)        print(a)    elif opc == 'c':        a = multi(x, y)        print(a)    elif opc == 'd':        a = div(x, y)        print(a)    main()if __name__ == '__main__':    main()
```



## Parámetros vs argumentos

No está del todo claro en este momento, ¿cuáles son los parámetros, verdad? De hecho, los parámetros son solo alias de valores, que se pueden pasar a una función. Considere el siguiente ejemplo:

```python
def send_postcard(address, message):    print("Sending a postcard to", address)    print("With the message:", message)send_postcard("Hilton, 97", "Hello, bro!")# Sending a postcard to Hilton, 97# With the message: Hello, bro!send_postcard("Piccadilly, London", "Hi, London!")# Sending a postcard to Piccadilly, London# With the message: Hi, London!# Se muestra que realizar con los argumentos al ser invocados
```

Como puede ver, esta función es un fragmento de código reutilizable, que se puede ejecutar con diferentes argumentos, es decir, diferentes valores pasados a esta función. Aquí, `address`y `message`son solo alias, bajo los cuales la función recibe valores y luego los procesa en el cuerpo.

Esta función toma exactamente 2 argumentos, por lo que no podrá ejecutarla con más o menos de 2 argumentos:

```python
send_postcard("Big Ben, London")TypeError: send_postcard() missing 1 required positional argument: 'message'
```

## Ejecución y devolución

Nuestra función anterior solo realizaba algunas acciones, pero no tenía ningún **valor de retorno** . Sin embargo, es posible que desee calcular algo en una función y devolver el resultado en algún momento. Mira el siguiente ejemplo:

```python
def celsius_to_fahrenheit(temps_c):    temps_f = temps_c * 9 / 5 + 32    return round(temps_f, 2)# Convert the boiling point of waterwater_bp = celsius_to_fahrenheit(100)print(water_bp)  # 212.0
```

La palabra clave `return`se utiliza para indicar qué valores genera la función. Básicamente, es el resultado de la llamada a la función. Entonces, en el ejemplo anterior, hemos almacenado el valor devuelto por nuestra función en la variable `water_bp`. Solo para estar seguros, imprimimos el resultado.

Una cosa más que decir es que las funciones no necesariamente tienen valores de retorno. La `print()`función conocida , de hecho, no devuelve nada. Examine el siguiente código:

```python
chant = print("We Will Rock You")print(chant)
```

Y su salida:

```python
We Will Rock YouNone
```

Declaramos la variable `chant`e invocamos `print()`. Obviamente, la función se ejecutó. Pero la variable en sí resultó ser el objeto **None** , lo que significa que la función llamada no tenía nada que devolver. El valor de `chant`es **Ninguno** .



El intérprete de Python deja de realizar la función después `return`. Pero, ¿qué pasa si el cuerpo de la función contiene **más** de una declaración de retorno? Entonces la ejecución terminará después de la primera. ¡Por favor tenlo en mente!



## Resumen

Por lo tanto, hemos aprendido la sintaxis para declarar funciones. Ahora también sabes que:

- Los parámetros de una función son simplemente alias o marcadores de posición para los valores que les pasará. Los parámetros se reinicializan cada vez que llama a la función. Dentro de la función, tiene acceso a estos valores, lo que significa que puede realizar cálculos sobre ellos.
- Una función puede simplemente realizar una acción sin devolver nada o devolver un resultado específico. Si su función no devuelve nada, asignar su resultado a una variable o imprimirlo le dará `None`.

Declarar sus propias funciones hace que su código sea más estructurado y reutilizable. Siempre que utilice el mismo código más de una vez, intente crear una función.

> En Hyperskill, a veces necesitamos verificar que el código del estudiante no use un método en particular. Por ejemplo, cuando la tarea es implementar el cálculo de factorial manualmente en lugar de usar la función `factorial()`del `math`módulo. ¿Cómo podríamos hacer eso?
>
> De hecho, es realmente sencillo. Podemos *anular* `math.factorial()` para hacer otra cosa: generar un error o imprimir un mensaje al alumno. Para hacerlo, primero definimos una función que hace lo que queremos (por ejemplo, imprime un mensaje) y luego le asignamos esta función `math.factorial`. Ahora, si el estudiante intenta usar `math.factorial`, se generará nuestra función personalizada. Esto sucede porque cuando existen varias funciones con el mismo nombre, la última siempre anula a la anterior.

For this task, imagine that you are a Hyperskill content creator and implement the example with the factorial yourself. Your program should override `math.factorial()` and make it print the message `"Don't cheat!"` instead of actually calculating a factorial.

```python
import mathdef cheat(x):    print("Don't cheat!")math.factorial = cheat# don't delete this line, pleasemath.factorial(23)###import mathmath.factorial = lambda x: print("Don't cheat!")num = 23math.factorial(num)
```



```python
# EJEMPLOWow! This problem is kind of tricky. If you're ready to put your thinking cap on, brace yourself and good luck! Otherwise, you can skip it for now and return any time later!The function closest_higher_mod_5 takes exactly one integer argument x and returns the smallest integer y such that:y is greater than or equal to x,y is divisible by 5.Correct the last line of the code below to make the function work.Sample Input 1:40Sample Output 1:40Sample Input 2:43Sample Output 2:45def closest_higher_mod_5(x):    remainder = x % 5    if remainder == 0:        return x    return x + 5 - remainder
```

```python
# OTRO EJEMPLOdef fahrenheit_to_celsius(f):    a = 32    return round((f - a) * 5 / 9, 3)
```





# Teoría: alcances (Scopes)

Un **scope** es una parte del programa donde se puede llegar a una determinada variable por su nombre. El alcance es un concepto muy importante en programación porque define la visibilidad de un nombre dentro del bloque de código.

##### Global frente a local

Cuando define una variable, se vuelve **global** o **local** . Si una variable se define en el nivel superior del módulo, se considera global. Eso significa que puede hacer referencia a esta variable desde cada bloque de código en su programa. Las variables globales pueden ser útiles cuando necesita compartir información de estado o alguna configuración entre diferentes funciones. Por ejemplo, puede almacenar el nombre de un usuario actual en una variable global y luego usarlo donde sea necesario. Hace que su código sea más fácil de cambiar: para establecer un nuevo nombre de usuario, solo tendrá que cambiar una única variable.

Las variables locales se crean cuando las define en el cuerpo de una función. Entonces, su nombre solo se puede resolver dentro del alcance de la función actual. Le permite evitar problemas con los efectos secundarios que pueden ocurrir al usar variables globales.

Considere el ejemplo para ver la diferencia entre las variables globales y locales:

```python
phrase = "Let it be"def global_printer():    print(phrase)  # we can use phrase because it's a global variableglobal_printer()  # Let it be is printedprint(phrase)  # we can also print it directlyphrase = "Hey Jude"global_printer()  # Hey Jude is now printed because we changed the value of phrasedef printer():    local_phrase = "Yesterday"    print(local_phrase)  # local_phrase is a local variableprinter()  # Yesterday is printed as expectedprint(local_phrase)  # NameError is raised
```

Por lo tanto, se puede acceder a una variable global tanto desde el nivel superior del módulo como desde el cuerpo de la función. Por otro lado, una variable local solo es visible dentro del alcance más cercano y no se puede acceder desde el exterior.

##### Regla LEGB

Una resolución variable en Python sigue la **regla LEGB** . Eso significa que el intérprete busca un nombre en el siguiente orden:

1. **Locales** . Variables definidas dentro del cuerpo de la función y no declaradas globales.
2. **Adjuntando** . Nombres del ámbito local en todas las funciones adjuntas desde el interior al exterior.
3. **Global** **s** . Nombres definidos en el nivel superior de un módulo o declarados globales con una `global`palabra clave.
4. **Incorporado** . Cualquier nombre integrado en Python.

Consideremos un ejemplo para ilustrar la regla LEGB:

```python
x = "global"def outer():    x = "outer local"    def inner():        x = "inner local"        def func():            x = "func local"            print(x)        func()    inner()outer()  # "func local"
```

Cuando se llama a la `print()`función dentro del, `func()`el intérprete necesita resolver el nombre `x`. Primero observará las variables más internas y buscará la definición local de `x`en `func()`función. En el caso del código anterior, el intérprete encontrará el local `x`in `func()`correctamente e imprimirá su valor `'func local'`,. [Aquí](https://pythontutor.com/visualize.html#code=x %3D "global" def outer()%3A    x %3D "outer local"    def inner()%3A        x %3D "inner local"        def func()%3A            x %3D "func local"            print(x)        func()    inner() outer()  %23 "func local"&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=[]&textReferences=false) está la visualización del código. ¡Compruébalo para ver cómo funciona casi en tiempo real!

Pero, ¿y si no hay una definición de `x`en `func()`? Luego, el intérprete se moverá hacia afuera y comenzará a `inner()`funcionar. Mira el siguiente ejemplo:

```python
x = "global"def outer():    x = "outer local"    def inner():        x = "inner local"        def func():            print(x)        func()    inner()outer()  # "inner local"
```

Como ves, el nombre `x`se resolvió en `inner()`función, ya que `"inner local"`se imprimió el valor .

Si también eliminamos la definición de `x`de la `inner()`función y ejecutamos el código nuevamente, el intérprete continuará la búsqueda entre los `outer()`locales de la misma manera. Si seguimos eliminando las líneas de definición de código `x`, el intérprete pasará a los `outer()`locales, luego a los globales y luego a los nombres integrados. En caso de que no haya un nombre integrado que coincida, se generará un error. Mire el ejemplo donde `x`el intérprete llega a la definición global de :

```python
x = "global"def outer():    def inner():        def func():            print(x)        func()    inner()outer()  # "global"
```

No te olvides de la regla LEGB si planeas usar funciones adjuntas.

##### Palabras clave "no local" y "global"

Ya mencionamos una forma de asignar una variable global: hacer una definición en el nivel superior de un módulo. Pero también hay una palabra clave especial `global`que nos permite declarar una variable global dentro del cuerpo de una función.

No puede cambiar el valor de una variable global dentro de la función sin usar la `global`palabra clave:

```python
x = 1def print_global():    print(x)print_global()  # 1def modify_global():    print(x)    x = x + 1modify_global()  # UnboundLocalError
```

Se genera un error porque estamos tratando de asignar a una variable local `x`la expresión que contiene `x`y el intérprete no puede encontrar esta variable en un ámbito local. Para corregir este error, debemos declarar `x`global:

```python
x = 1def global_func():    global x    print(x)    x = x + 1global_func()  # 1global_func()  # 2global_func()  # 3
```

Cuando `x`es global, puede incrementar su valor dentro de la función.

`nonlocal` La palabra clave nos permite asignar variables en el ámbito externo (pero no global):

```python
def func():    x = 1    def inner():        x = 2        print("inner:", x)    inner()    print("outer:", x)def nonlocal_func():    x = 1    def inner():        nonlocal x        x = 2        print("inner:", x)    inner()    print("outer:", x)func()  # inner: 2        # outer: 1nonlocal_func()  # inner: 2                 # outer: 2
```

Aunque `global`y `nonlocal`están presentes en el idioma, no se usan a menudo en la práctica, porque estas palabras clave hacen que los programas sean menos predecibles y más difíciles de entender.

##### ¿Por qué necesitamos osciloscopios?

En primer lugar, ¿por qué Python necesita la distinción entre alcance global y local? Bueno, a partir de la experiencia de algunos otros lenguajes de programación que no tienen ámbitos *locales* , quedó claro que usar solo un ámbito global es muy inconveniente: cuando se puede acceder a todas las variables desde todas las partes del código, es inevitable un montón de errores. Cuanto más largo sea el código, más difícil será recordar todos los nombres de las variables y no cambiar accidentalmente el valor de la variable que se suponía que debía mantener intacta. Por lo tanto, Python le ahorra problemas al permitirle "aislar" algunas variables del resto del código cuando lo divide en funciones.

Por otro lado, ¿por qué entonces necesitamos *un* alcance *global* ? Bueno, como ya se mencionó anteriormente, el alcance global es una de las formas más fáciles de retener información entre llamadas a funciones: mientras que las variables locales desaparecen en el momento en que la función regresa, las variables globales permanecen y ayudan a las funciones a transferir los datos necesarios entre sí. De manera similar, las variables globales pueden permitir la comunicación entre procesos más complejos, como subprocesos en aplicaciones multiproceso.

##### Resumen

En este tema, hemos descubierto la diferencia entre las variables globales y locales y las palabras clave "no locales" y "globales", hemos aprendido la regla LEGB y cómo los ámbitos pueden ser útiles en la práctica. ¡Espero que encuentre útil este nuevo conocimiento!





# Teoría: métodos básicos de cadena

Como ya sabe, la cadena es uno de los tipos de datos más importantes en Python. Para facilitar el trabajo con cadenas, Python tiene muchos métodos especiales de cadena incorporados. Estamos a punto de conocer algunos de ellos.



Sin embargo, es importante recordar que la cadena es un tipo de datos **inmutable** . Significa que no puede simplemente cambiar la cadena en el lugar, por lo que la mayoría de los métodos de cadena **devuelven una copia** de la cadena (con varias excepciones). Para guardar los cambios realizados en la cadena para su uso posterior, debe crear una **nueva variable** para la copia que realizó o **asignar el mismo nombre** a la copia. Entonces, qué hacer con la salida de los métodos depende de si va a usar la cadena original o su copia más adelante.



## "Cambiar" una cadena

El primer grupo de métodos de cadena consiste en los que "cambian" la cadena de una manera específica, es decir, devuelven la copia con algunos cambios realizados.

La sintaxis para llamar a un método es la siguiente: primero se proporciona una cadena (o el nombre de una variable que contiene una cadena), luego aparece un punto seguido del nombre del método y paréntesis en los que se enumeran los argumentos.

Aquí hay una lista de métodos de cadena comunes de ese tipo:

- **`str.replace(old, new, count)`**reemplaza todas las apariciones de la `old`cadena con `new`uno. El `count`parámetro es opcional y, si se especifica, solo `count`se reemplazan las primeras apariciones en la cadena dada.
- **`str.upper()`** convierte todos los caracteres de la cadena a mayúsculas.
- **`str.lower()`** convierte todos los caracteres de la cadena a minúsculas.
- **`str.title()`** convierte el primer carácter de cada palabra a mayúsculas.
- **`str.swapcase()`** convierte mayúsculas a minúsculas y viceversa.
- **`str.capitalize()`** cambia el primer carácter de la cadena a mayúsculas y minúsculas y el resto a minúsculas.

Y aquí hay un ejemplo de cómo se utilizan estos métodos (tenga en cuenta que no guardamos el resultado de cada método):

```python
message = "bonjour and welcome to Paris!"print(message.upper())  # BONJOUR AND WELCOME TO PARIS!# `message` is not changedprint(message)  # bonjour and welcome to Paris!title_message = message.title() # `title_message` contains a new string with all words capitalizedprint(title_message)  # Bonjour And Welcome To Paris!print(message.replace("Paris", "Lyon"))  # bonjour and welcome to Lyon!replaced_message = message.replace("o", "!", 2)print(replaced_message)  # b!nj!ur and welcome to Paris!# again, the source string is unchanged, only its copy is modifiedprint(message)  # bonjour and welcome to Paris!
```

## "Editar" una cadena

A menudo, cuando lee una cadena de algún lugar (un archivo o la entrada), debe editarla para que contenga solo la información que necesita. Por ejemplo, la cadena de entrada puede tener muchos espacios en blanco innecesarios o algunas combinaciones de caracteres finales. Los "edición" métodos que pueden ayudar a que son **`strip()`**, **`rstrip()`**y **`lstrip()`**.

- **`str.lstrip([chars])`**elimina los caracteres principales (es decir, caracteres del lado izquierdo). Si `chars`no se especifica el argumento , se eliminan los espacios en blanco iniciales.
- **`str.rstrip([chars])`**elimina los caracteres finales (es decir, caracteres del lado derecho). El valor predeterminado para el argumento `chars`también es un espacio en blanco.
- **`str.strip([chars])`**elimina tanto los caracteres iniciales como los finales. El valor predeterminado es el espacio en blanco.

El `chars`argumento, cuando se especifica, es una cadena de caracteres que deben eliminarse del final o del principio de la palabra (según el método que esté utilizando). Mira como funciona:

```python
whitespace_string = "     hey      "normal_string = "incomprehensibilities"# delete spaces from the left sidewhitespace_string.lstrip()  # "hey      "# delete all "i" and "s" from the left sidenormal_string.lstrip("is")  # "ncomprehensibilities"# delete spaces from the right sidewhitespace_string.rstrip()  # "     hey"# delete all "i" and "s" from the right sidenormal_string.rstrip("is")  # "incomprehensibilitie"# no spaces from both sideswhitespace_string.strip()  # "hey"# delete all trailing "i" and "s" from both sidesnormal_string.strip("is")  # "ncomprehensibilitie"
```

Tenga en cuenta que los métodos `strip()`, `lstrip()`y `rstrip()`eliminan todas las combinaciones posibles de caracteres especificados:

```python
word = "Mississippi"# starting from the right side, all "i", "p", and "s" are removed:print(word.rstrip("ips"))  # "M"# the word starts with "M" rather than "i", "p", or "s", so no chars are removed from the left side:print(word.lstrip("ips"))  # "Mississippi"# "M", "i", "p", and "s" are removed from both sides, so nothing is left:print(word.strip("Mips"))  # ""
```

Úselos con cuidado, o puede terminar con una cadena vacía.

## Resumen

En resumen, hemos considerado los principales métodos para cadenas. Aquí hay un breve resumen:

- Mientras trabaja con cadenas, debe recordar que las cadenas son **inmutables** , por lo tanto, todos los métodos que las "cambian" solo devuelven la copia de una cadena con los cambios necesarios.
- Si desea guardar el resultado de una llamada a un método para su uso posterior, debe asignar este resultado a una variable (ya sea la misma o la que tiene un nombre diferente).
- Si desea usar este resultado solo una vez, por ejemplo, en comparaciones o simplemente para imprimir la cadena formateada, puede usar el resultado en el lugar, como lo hicimos dentro `print()`.

| EJEMPLO                      | FUNCIÓN                                                      |
| ---------------------------- | ------------------------------------------------------------ |
| 'robot'.replace('o', '_', n) | Reemplaza n primeras apariciones de una subcadena antigua por una nueva. |
| "".replace("", 'robot')      | Inserta una subcadena en la línea vacía.                     |
| 'robot'.replace (' o ', "")  | Elimina subcadenas de la línea.                              |
| 'robot'.replace ("", "")     | Agrega espacio entre letras.                                 |

 

```python
name = input()def normalize(new_name):    # put your code here    old_values = ["é", "ë", "á", "å", "œ", "æ"]    new_values = ["e", "e", "a", "a", "oe", "ae"]    for count, value in enumerate(old_values):        new_name = new_name.replace(value, new_values[count])    return new_nameprint(normalize(name))####name = input()def normalize(old_name):    working_dict = {        'é': 'e',        'ë': 'e',        'á': 'a',        'å': 'a',        'œ': 'oe',        'æ': 'ae',    }    new_name = old_name    for old_char, new_char in working_dict.items():        new_name = new_name.replace(old_char, new_char)    return new_nameprint(normalize(name))###name = input()def normalize():    new_name = name.replace("é", "e").replace("ë", "e")    new_name = new_name.replace("á", "a").replace("å", "a")    new_name = new_name.replace("œ", "oe").replace("æ", "ae")    # put your code here    print(new_name)normalize()
```



---



## ¿Qué es un Diccionario de datos?

Un Diccionario es una estructura de datos y un tipo de dato en Python con características especiales que nos permite almacenar cualquier tipo de valor como enteros, cadenas, listas e incluso otras funciones. Estos diccionarios nos permiten además identificar cada elemento por una clave (Key).

1. Para definir un diccionario, se encierra el listado de valores entre llaves. Las parejas de clave y valor se separan con comas, y la clave y el valor se separan con dos puntos.

    ```python
    diccionario = {'nombre' : 'Carlos', 'edad' : 22, 'cursos': ['Python','Django','JavaScript'] }
    ```

2. Podemos acceder al elemento de un Diccionario mediante la clave de este elemento, como veremos a continuación:

    ```python
    print diccionario['nombre'] #Carlosprint diccionario['edad']#22print diccionario['cursos'] #['Python','Django','JavaScript']
    ```

3. También es posible insertar una lista dentro de un diccionario. Para acceder a cada uno de los cursos usamos los índices:

    ```python
    print diccionario['cursos'][0]#Pythonprint diccionario['cursos'][1]#Djangoprint diccionario['cursos'][2]#JavaScript
    ```

4. Para recorrer todo el Diccionario, podemos hacer uso de la estructura for:

    ```python
    for key in diccionario:  print key, ":", diccionario[key]
    ```

## Métodos de los Diccionarios

- dict ()

    Recibe como parámetro una representación de un diccionario y si es factible, devuelve un diccionario de datos.

    ```python
    dic =  dict(nombre='nestor', apellido='Plasencia', edad=22)dic → {‘nombre’ : 'nestor', ‘apellido’ : 'Plasencia', ‘edad’ : 22}
    ```

- zip()

    Recibe como parámetro dos elementos iterables, ya sea una cadena, una lista o una tupla. Ambos parámetros deben tener el mismo número de elementos. Se devolverá un diccionario relacionando el elemento i-esimo de cada uno de los iterables.

    ```python
    dic = dict(zip('abcd',[1,2,3,4]))dic →   {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    ```

- items()

    Devuelve una lista de tuplas, cada tupla se compone de dos elementos: el primero será la clave y el segundo, su valor.

    ```python
    dic =   {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}items = dic.items()items → [(‘a’,1),(‘b’,2),(‘c’,3),(‘d’,4)]
    ```

- keys()

    Retorna una lista de elementos, los cuales serán las claves de nuestro diccionario.

    ```python
    dic =  {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}keys= dic.keys()keys→ [‘a’,’b’,’c’,’d’] 
    ```

- values()

    Retorna una lista de elementos, que serán los valores de nuestro diccionario.

    ```python
    dic =  {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}values= dic.values()values→ [1,2,3,4] 
    ```

- clear()

    Elimina todos los ítems del diccionario dejándolo vacío.

    ```python
    dic 1 =  {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}dic1.clean()dic1 → { }
    ```

- copy()

    Retorna una copia del diccionario original.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}dic1 = dic.copy()dic1 → {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}
    ```

- fromkeys()

    Recibe como parámetros un iterable y un valor, devolviendo un diccionario que contiene como claves los elementos del iterable con el mismo valor ingresado. Si el valor no es ingresado, devolverá none para todas las claves.

    ```python
    dic = dict.fromkeys(['a','b','c','d'],1)dic →  {‘a’ : 1, ’b’ : 1, ‘c’ : 1 , ‘d’ : 1}
    ```

- get()

    Recibe como parámetro una clave, devuelve el valor de la clave. Si no lo encuentra, devuelve un objeto none.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}valor = dic.get(‘b’) valor → 2
    ```

- pop()

    Recibe como parámetro una clave, elimina esta y devuelve su valor. Si no lo encuentra, devuelve error.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}valor = dic.pop(‘b’) valor → 2dic → {‘a’ : 1, ‘c’ : 3 , ‘d’ : 4}
    ```

- setdefault()

    Funciona de dos formas. En la primera como get

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}valor = dic.setdefault(‘a’)valor → 1
    ```

    Y en la segunda forma, nos sirve para agregar un nuevo elemento a nuestro diccionario.

    ```python
    dic = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}valor = dic.setdefault(‘e’,5)dic → {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4 , ‘e’ : 5}
    ```

- update()

    Recibe como parámetro otro diccionario. Si se tienen claves iguales, actualiza el valor de la clave repetida; si no hay claves iguales, este par clave-valor es agregado al diccionario.

    ```python
    dic 1 = {‘a’ : 1, ’b’ : 2, ‘c’ : 3 , ‘d’ : 4}dic 2 = {‘c’ : 6, ’b’ : 5, ‘e’ : 9 , ‘f’ : 10}dic1.update(dic 2)dic 1 → {‘a’ : 1, ’b’ : 5, ‘c’ : 6 , ‘d’ : 4 , ‘e’ : 9 , ‘f’ : 10}
    ```

Estos son algunos de los métodos más útiles y más utilizados en los Diccionarios. Python es un gran lenguaje de programación que nos permite programar de una manera realmente sencilla. Si deseas conocer mucho más y aprender a profundidad esta tecnología, ingresa al [Curso de Python](https://devcode.la/cursos/python/) que tenemos en Devcode. 

> https://devcode.la/tutoriales/diccionarios-en-python/

---

## Theory: Boolean logic

 23 minutes1 / 10 problems solved

Unskip this topicStart practicing

**26620** users solved this topic. Latest completion was **about 3 hours ago**.

In programming languages, the boolean, or logical, type is a common way to represent something that has only two opposite states like *on* or *off*, *yes* or *no*, etc. It's a very useful type which you will quickly see for yourself when you start working on your projects or even write small programs. In this topic, we'll look at the boolean type in Python and learn how to use it.

##### Boolean type

The **Boolean** type, or simply `bool`, is a special data type that has only two possible values: `True` and `False`. In Python, the names of boolean values start with a capital letter.

If you are writing an application that keeps track of door openings, you'll find it natural to use `bool` to store the current door state.

```python
is_open = Trueis_closed = Falseprint(is_open)    # Trueprint(is_closed)  # False
```

##### Boolean operations

There are three built-in boolean operators in Python: `and`, `or` and `not`. The first two are **binary** operators which means that they expect two arguments. `not` is a **unary** operator, it is always applied to a single operand. First, let's look at these operators applied to the boolean values.

- and

  ​     

    is a binary operator, it takes two arguments and returns

     

    ```python
    True
    ```

     

    if both arguments are true, otherwise, it returns

     

    ```python
    False
    ```

    .

    ```python
    a = True and True    # Trueb = True and False   # Falsec = False and False  # Falsed = False and True   # False
    ```

- or

  ​     

    is a binary operator, it returns

     

    ```python
    True
    ```

     

    if at least one argument is true, otherwise, it returns

     

    ```python
    False
    ```

    .

    ```python
    a = True or True    # Trueb = True or False   # Truec = False or False  # Falsed = False or True   # True
    ```

- not

  ​     

    is a unary operator, it reverses the boolean value of its argument.

    ```python
    to_be = True           # to_be is Truenot_to_be = not to_be  # not_to_be is False
    ```

##### The precedence of boolean operations

Logical operators have a different priority and it affects the order of evaluation. Here are the operators in order of their priorities: `not`, `and`, `or`. So, `not` is considered first, then `and`, finally `or`. Having this in mind, consider the following expression:

```python
print(False or not False)  # True
```

First, the part `not False` gets evaluated, and after evaluation, we are left with `False or True`. This results in `True`, if you recall the previous section.

While dealing solely with the boolean values may seem obvious, the precedence of logical operations will be quite important to remember when you start working with so-called **truthy** and **falsy** values.

##### Truthy and falsy values

Though Python has the boolean data type, we often want to use non-boolean values in a logical context. And Python lets you test almost any object for truthfulness. When used with logical operators, values of non-boolean types, such as integers or strings, are called **truthy** or **falsy**. It depends on whether they are interpreted as `True` or `False`.

The following values are evaluated to `False` in Python:

- constants defined to be false: `None` and `False`,
- zero of any numeric type: `0`, `0.0`,
- empty sequences and containers: `""`, `[]`, `{}`.

Anything else generally evaluates to `True`. Here is a couple of examples:

```python
print(0.0 or False)  # Falseprint("True" and True)  # Trueprint("" or False)  # False
```

Generally speaking, `and` and `or` could take any arguments that can be tested for a boolean value.

Now we can demonstrate more clearly the difference in operator precedence:

```python
# `and` has a higher priority than `or`truthy_integer = False or 5 and 100  # 100
```

Again, let's break the above expression into parts. Since the operator `and` has a higher priority than `or`, we should look at the `5 and 100` part. Both `100` and `5` happen to be truthy values, so this operation will return `100`. You have never seen this before, so it's natural to wonder why we have a number instead of the `True` value here. The explanation is as follows:



The operators `or` and `and` return one of their operands, not necessarily of the boolean type. Nonetheless, `not` always returns a boolean value.



Coming back to the original expression, you can see that the last part `False or 100` does exactly the same thing, returns `100` instead of `True`.

Another tricky example is below:

```python
tricky = not (False or '')  # True
```

A pair of parentheses is a way to specify the order in which the operations are performed. Thus, we evaluate this part of the expression first: `False or ''`. This operand `''` evaluates to `False` and `or` returns this empty string. Since the result of the enclosed expression is negated, we get `True` in the end: `not ''` is the same as `True`. Why didn't we get, say, a non-empty string? The `not` operator creates a new value, which by default has the boolean type. So, as stated earlier, the unary operator always returns a logical value.

##### Short-circuit evaluation

The last thing to mention is that logical operators in Python are **short-circuited**. That's why they are also called **lazy**. That means that the second operand in such an expression is evaluated only if the first one is not sufficient to evaluate the whole expression.

- `x and y` returns x if x is falsy; otherwise, it evaluates and returns y.
- `x or y` returns x if x is truthy; otherwise, it evaluates and returns y.

For instance:

```python
# division is never evaluated, because the first argument is Truelazy_or = True or (1 / 0)  # True# division is never evaluated, because the first argument is Falselazy_and = False and (1 / 0)  # False
```

##### Summary

So, in this topic, we've learned about a boolean type in Python, what boolean operations it has and their priority. We also familiarized ourselves with the concept of truthy and falsy values and why logical operators in Python are called short-circuited. Those were the very basics of boolean values and logical operations in Python. It's definitely good to know them right from the beginning!



# Teoría: comparaciones

Escribir código sin comparar ningún valor en él solo te llevará hasta cierto punto. Ahora es el momento de dominar esta habilidad.

##### Operadores de comparación

**Las** operaciones de **comparación** o **relación le** permiten comparar dos valores y determinar la relación entre ellos. Hay diez operadores de comparación en Python:

- `<` estrictamente menos que
- `<=` menor o igual
- `>` estrictamente mayor que
- `>=` mayor que o igual
- `==` igual
- `!=` no es igual
- `is` identidad de objeto
- `is not` identidad de objeto negada
- `in` afiliación
- `not in` membresía negada.

El resultado de aplicar estos operadores es siempre `bool`. Las siguientes secciones se centran en los primeros seis operadores ( `<`, `<=`, `>`, `>=`, `==`, `!=`), pero se pueden encontrar más detalles acerca de la identidad y la prueba de miembros en los próximos temas.

##### Comparando enteros

En este tema, cubriremos solo la comparación de enteros.

```python
a = 5b = -10c = 15result_1 = a < b   # Falseresult_2 = a == a  # Trueresult_3 = a != b  # Trueresult_4 = b >= c  # False
```

Cualquier expresión que devuelva un número entero también es un operando de comparación válido:

```python
calculated_result = a == b + c  # True
```

Dadas las variables definidas `a`, `b`y `c`, básicamente verificamos si `5`es igual a `-10 + 15`, que es cierto.

##### Encadenamiento de comparación

Dado que las operaciones de comparación devuelven valores booleanos, puede unirlos utilizando operadores lógicos. En este caso, es importante conocer su prioridad, es decir, cuál se ejecuta primero. Todas las operaciones de comparación tienen la misma prioridad y es menor que la de cualquier operación aritmética, de desplazamiento o bit a bit.

```python
x = -5y = 10z = 12result = x < y and y <= z  # True
```

En Python, existe una forma más elegante de escribir comparaciones complejas. Se llama **encadenamiento** . Por ejemplo, `x < y <= z`es casi equivalente a la expresión que vio en el último ejemplo. La diferencia es que `y`se evalúa solo una vez.

```python
result = 10 < (100 * 100) <= 10000  # True, the multiplication is evaluated once
```



Por favor, preste atención al hecho de que las herramientas de la calidad del código suelen recomendar *el encadenamiento de* las comparaciones en lugar de *unirse a* ellos.



Sin embargo, el encadenamiento de comparación debe usarse con cuidado porque a veces las expresiones pueden volverse complicadas, por lo que el resultado dependerá del orden de los operadores y de cómo se coloquen los paréntesis. Considere este ejemplo:

```python
a = 1b = 2c = 3e = 4f = 5g = 6print(b + c <= e or f + g >= e == f == 5)      # Falseprint((b + c <= e or f + g >= e) == (f == 5))  # True
```

La primera expresión es `False`porque se evalúa en consecuencia: la parte `b + c <= e or f + g >= e`es `True`pero no es igual a `f`, por lo que la expresión completa ya es `False`. En el segundo caso, ambos operandos son `True`y `True`iguales `True`, por lo que la expresión final también lo es `True`.

##### Lógica y aritmética

Veamos otro caso interesante. Al comienzo del tema, aprendimos que el resultado de aplicar operadores de comparación es siempre `bool`. Sin embargo, si hay una parte lógica y aritmética en una expresión, podríamos ver un comportamiento inusual:

```python
# True and-expressions return the result of the last operation:print(b + c * f >= e and (f + g) * c)  # 33print((f + g) * c and b + c * f >= e)  # True# False and-expressions return a boolean False value:print(b + c * f <= e and (f + g) * c)  # Falseprint((f + g) * c and b + c * f <= e)  # False# True or-expressions return the result of the first operation:print(b + c * f >= e or (f + g) * c)  # Trueprint((f + g) * c or b + c * f >= e)  # 33# True-False or-expressions return the True part:print((f + g) * c or b + c * f <= e)  # 33print(b + c * f <= e or (f + g) * c)  # 33
```

Puede parecer confuso a primera vista pero, si lo piensa, cada valor impreso es perfectamente legal y cumple con la lógica matemática común.

##### Resumen

En este tema, nos familiarizamos con los operadores de comparación de Python, aprendimos cómo comparar enteros y usamos el encadenamiento de comparación. ¡Estos operadores básicos definitivamente le serán de gran ayuda en el futuro!

### PRACTICA



Imagine, you are developing a rule in terms of logical and comparison operations to determine whether you should enroll a student in your course or not. [Imagínese, está desarrollando una regla en términos de operaciones lógicas y de comparación para determinar si debe inscribir a un estudiante en su curso o no.] The rule itself looks like this: [La regla en sí tiene este aspecto:]

```python
enroll_student = ((average_grade >= 40 and recommended_by_tutor) [Enroll_student = ((average_grade> = 40 y recommended_by_tutor)]              or (finished_introductory_course and introductory_course_grade > 85)) [O (curso_ introductorio_ finalizado y curso_ curso_ introductorio> 85))] 
```

Parameters meaning: [Significado de los parámetros:]

- **average_grade** is an integer variable that shows the student's average grade. [Average_grade es una variable entera que muestra la calificación promedio del estudiante.]
- **recommended_by_tutor** is a bool variable that shows whether the student has a recommendation from the tutor. [Recommended_by_tutor es una variable bool que muestra si el alumno tiene una recomendación del tutor.]
- **finished_introductory_course** is a bool variable that shows whether the student finished the introductory course. [Finish_introductory_course es una variable bool que muestra si el estudiante terminó el curso introductorio.]
- **introductory_course_grade** is an integer variable that shows the student's introductory course grade. [Introductory_course_grade es una variable entera que muestra la calificación del curso introductorio del estudiante.]

The table of students who wish to enroll: [La tabla de estudiantes que desean matricularse:]

|                    | average_grade [Nota media] | recommended_by_tutor [Recomendado_por_tutor] | finished_introductory_course [Curso_introductorio_completado] | introductory_course_grade [Introductory_course_grade] |
| ------------------ | -------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| **Anne [Ana]**     | 49 [49]                    | True [Cierto]                                | False [Falso]                                                | 0 [0]                                                 |
| **John [John]**    | 41 [41]                    | False [Falso]                                | True [Cierto]                                                | 76 [76]                                               |
| **Frank [Franco]** | 37 [37]                    | True [Cierto]                                | True                                                         | 97                                                    |
| **Victoria**       | 40                         | True                                         | True                                                         | 86                                                    |
| **Mary**           | 49                         | False                                        | True                                                         | 85                                                    |
| **Sam**            | 33                         | False                                        | True                                                         | 51                                                    |

Anne, Frank Victoria

# Función Python id ()

[❮ Funciones integradas](https://www.w3schools.com/python/python_ref_functions.asp)

------

### Ejemplo

Devuelve la identificación única de un objeto de tupla:

```python
x = ('apple', 'banana', 'cherry')y = id(x)
```

[Inténtalo tú mismo "](https://www.w3schools.com/python/trypython.asp?filename=demo_ref_id)

------

## Definición y uso

La `id()`función devuelve una identificación única para el objeto especificado.

Todos los objetos en Python tienen su propia identificación única.

La identificación se asigna al objeto cuando se crea.

La identificación es la dirección de memoria del objeto y será diferente cada vez que ejecute el programa. (a excepción de algún objeto que tiene una identificación única constante, como números enteros de -5 a 256)

------

## Sintaxis

```python
id(*object*)
```



## Valores paramétricos

| Parameter | Description                                  |
| :-------- | :------------------------------------------- |
| *object*  | Any object, String, Number, List, Class etc. |

```python
# The parental gene sequences are stored here
one_ancestor = input()
other_ancestor = input()

# Calculate the identity of a new alien here
new_alien = (id(one_ancestor) + id(other_ancestor)) / 2
```

# Theory: Identity testing

A estas alturas, ya sabe cómo trabajar con valores en Python. Por ejemplo, sabe cómo realizar operaciones aritméticas con números. Pero, *¿qué* es un valor en Python? No puede ser algo abstracto, como en matemáticas, porque una computadora debería poder trabajar con él. En este tema, obtendrá cierta comprensión de los valores en Python.

##### Muchas copias de valores iguales

Pueden existir valores iguales en Python en muchas copias. Considere el siguiente código:

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a)  # [1, 2, 3]
print(b)  # [1, 2, 3]
print(c)  # [1, 2, 3]
```

Parece que todas estas variables son iguales. Pero no lo son en cierto sentido. Para verlo modifiquemos la lista `a`.

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

a[0] = 5

print(a)  # [5, 2, 3] - changed
print(b)  # [1, 2, 3] - didn't change
print(c)  # [5, 2, 3] - also changed
```

La razón es que creamos **dos copias** de `[1, 2, 3]`. Variables `a`y se `c`refieren a la primera copia, y se `b`refiere a la segunda copia. Cambiar uno de ellos no afecta al otro.

A estas copias las llamamos **objetos** . Un objeto se almacena en la memoria y contiene información sobre un valor abstracto que representa. Entonces puede haber varios objetos que representen el mismo valor. Puede tratar objetos como gemelos. A primera vista, parecen idénticos, pero en realidad son personas diferentes.

Veamos cómo distinguir gemelos en Python.

##### Función de identificación

Cada objeto en Python tiene un número entero asociado llamado **identidad** . Puede obtener este número entero pasando el objeto a la función `id`. Los números, cadenas y otros tipos primitivos también son objetos y también tienen una identidad. La identidad nunca cambia durante la vida del objeto. Los diferentes objetos en la memoria tienen diferentes identidades.

Usándolo podemos distinguir dos objetos en Python que contienen el mismo valor. Es similar a distinguir a los gemelos mirando sus documentos de identidad.

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # True, they contain the same value

# But they have different identities
print(id(a))  # 4558721352
print(id(b))  # 4560238984
```



Python genera `id`sobre la marcha, ejecutar los fragmentos de código anteriores le dará otros valores enteros. Además, los objetos nuevos pueden tener identificadores más pequeños que los objetos creados anteriormente.



Pero si dos variables se refieren al mismo objeto, la `id`función devolverá el mismo valor.

```python
a = [1, 2, 3]
c = a

print(a == c)  # True, they contain the same value

# And they also have the same identity
print(id(a))  # 4558721352
print(id(c))  # 4558721352
```

Como puede ver, las variables `a`y `c`comparten la identidad, lo que significa que se refieren al mismo objeto.

##### Prueba de identidad

Puede comprobar si dos variables se refieren al mismo objeto comparando los resultados de la `id`función. Pero hay una forma mejor de hacerlo. Python tiene un **operador de** **identidad** que verifica si dos objetos tienen **la misma identidad** . El resultado es un valor booleano: o . No debe confundirlo con el **operador de** **igualdad** que prueba si dos objetos contienen **el mismo valor** . `is``True``False` `==`

```python
a = [1, 2, 3]
b = [1, 2, 3]

identity_test = a is b  # False, because a and b refer to different objects in memory
equality_test = a == b  # True, because a and b contain the same value

b = a

identity_test = a is b  # True, because now both variables refer to the same object
```

El `is not`operador es la **negación** del `is`operador. Devuelve `True`si sus operandos se refieren a diferentes objetos.

```python
a = [1, 2, 3]
b = [4, 5]

print(a is not b)  # True, as expected
```

##### Utilice el operador de identidad con cuidado

El uso del operador de identidad en lugar del operador de igualdad puede dar lugar a muchos errores. El siguiente ejemplo muestra el peligro del `is`operador.

```python
a = int(input())  # 10
b = int(input())  # 10
print(a is b)     # True
print(id(a))      # 4462719392
print(id(b))      # 4462719392

a = int(input())  # 10000
b = int(input())  # 10000
print(a is b)     # False
print(id(a))      # 4466218032
print(id(b))      # 4466218160
```

La razón de un comportamiento tan extraño es que Python optimiza el uso de números enteros pequeños entre -5 y 256. Se usan comúnmente, por lo que Python no crea un objeto nuevo cada vez, sino que da una referencia a un número existente. Lo mismo ocurre con las cadenas cortas.

Sin embargo, el caso de un gran número depende de la implementación. Puede obtener `True`la siguiente expresión:

```python
a = 10000
b = 10000
print(a is b)  # True or False depending on your system
```

##### Cuándo usar el operador de identidad

El caso adecuado para usar el `is`operador es probar si algo es `None`. `None`es una palabra clave especial en Python que se usa para definir ***ningún valor\*** .

Es seguro de usar `is` en este caso, porque `None`es un **singleton** . Esto significa que el `None`objeto se crea solo una vez y luego se usa cada vez que hace referencia a `None`su código.

Es común usarlo `None`como valor predeterminado para argumentos opcionales en funciones.

```python
def say_hello(name=None):
    if name is None:
        print('Hello!')
    else:
        print(f'Hello, {name}!')


say_hello()        # 'Hello!'
say_hello('Nick')  # 'Hello, Nick!'
```

`True`y `False`también son singleton, por lo que también puedes usarlos `is`con ellos.

##### Resumen

En este tema, hemos aprendido un poco sobre los objetos en Python y cómo probar la identidad de los objetos. Para no cometer errores en su código, preste atención a los siguientes puntos:

- Puede haber muchos objetos que contengan el mismo valor. Son **iguales** pero no **idénticos** .
- El operador de identidad no compara valores, pero comprueba si sus operandos se refieren al mismo objeto.
- No utilice el operador de identidad con tipos primitivos.
- Utilice el operador de identidad para probar si algo lo es `None`.

##### Prueba de identidad

[Teoría completa abierta](https://hyperskill.org/learn/step/8077)

```python
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a)  # [1, 2, 3]
print(b)  # [1, 2, 3]
print(c)  # [1, 2, 3]
a = [1, 2, 3]
b = [1, 2, 3]
c = a

a[0] = 5

print(a)  # [5, 2, 3] - changed
print(b)  # [1, 2, 3] - didn't change
print(c)  # [5, 2, 3] - also changed
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # True, they contain the same value

# But they have different identities
print(id(a))  # 4558721352
print(id(b))  # 4560238984
a = [1, 2, 3]
c = a

print(a == c)  # True, they contain the same value

# And they also have the same identity
print(id(a))  # 4558721352
print(id(c))  # 4558721352
a = [1, 2, 3]
b = [1, 2, 3]

identity_test = a is b  # False, because a and b refer to different objects in memory
equality_test = a == b  # True, because a and b contain the same value

b = a

identity_test = a is b  # True, because now both variables refer to the same object
a = [1, 2, 3]
b = [4, 5]

print(a is not b)  # True, as expected
a = int(input())  # 10
b = int(input())  # 10
print(a is b)     # True
print(id(a))      # 4462719392
print(id(b))      # 4462719392

a = int(input())  # 10000
b = int(input())  # 10000
print(a is b)     # False
print(id(a))      # 4466218032
print(id(b))      # 4466218160
a = 10000
b = 10000
print(a is b)  # True or False depending on your system
def say_hello(name=None):
    if name is None:
        print('Hello!')
    else:
        print(f'Hello, {name}!')


say_hello()        # 'Hello!'
say_hello('Nick')  # 'Hello, Nick!'
```

```python
def check_values(first_value, second_value):
    return bool(first_value) and bool(second_value)
```

> You need to check if variables `a` and `b` refer to the same object. Select all correct ways to do it.
>
> a is b   /   id(a) == id(b)

```python
### EJEMPLO
Write a function that returns an object whose identity ends with 888.

Iterate numbers from 0 to 10 000 and check their identity via id() to find a value ending with ...888.

def object_with_beautiful_identity():
object_with_beautiful_identity()
def object_with_beautiful_identity():
    for i in range(10_000):
        # Change the next line
        if str(id(i)).endswith('888'):
            return i
    return None
```

```python
def find_my_list(lists, my_list):
    for position, lst in enumerate(lists):
        # Change the next line
        if id(lst) == id(my_list):
            return position
    return None
```

| condicional | sustituto |
| ----------- | --------- |
| ==          | is        |
| !=          | is not    |

# Teoría: Diccionario

Imagina que eres un observador de aves sentado en el parque y contando los pájaros que ves. ¡Has observado una docena de palomas, 5 gorriones e incluso un pico rojo! Ahora, suponga que desea almacenar estas observaciones para su uso posterior. Debe recordar exactamente cuántas aves de cada tipo ha visto. Por lo tanto, una lista simple con números no servirá porque no podrá saber qué número se refiere a qué ave. Necesita un tipo de datos que pueda asociar una cosa con otra: en nuestro caso, el nombre del ave con el número de observaciones.

Afortunadamente, Python tiene un tipo de **diccionario** ( `dict`). Puede imaginarse un diccionario real, un libro grande con definiciones de muchas palabras. La definición contiene dos partes: la palabra en sí (llamémosla **clave** ) y su definición (un **valor** ). En nuestro ejemplo de observador de aves, las claves son los nombres de las aves ("paloma", "gorrión" y "pico rojo") y los valores son cuántas aves de ese tipo hemos visto (12, 5 y 1, respectivamente). .

En programación, los diccionarios funcionan de manera similar: si queremos almacenar un objeto, necesitamos seleccionar alguna clave para él y poner nuestro objeto como un valor para esa clave en nuestro diccionario.

##### Creación de diccionario

Un diccionario consta de una colección de pares clave-valor. Cada par clave-valor asigna la clave a su valor asociado. Si ya conoce los valores necesarios, la forma más sencilla de crear un diccionario es utilizar las **llaves** con una lista de `key: value`pares separados por comas . Si desea crear un diccionario vacío, también puede hacerlo con la ayuda de llaves. Tenga en cuenta que los valores de un diccionario pueden ser de **diferentes tipos** .

```python
birds = {"pigeon": 12, "sparrow": 5, "red crossbill": 1}
prices = {'espresso': 5.0, 'americano': 8.0, 'latte': 10, 'pastry': 'various prices'}
empty_dict = {}

print(type(birds))  # <class 'dict'>
print(type(prices))  # <class 'dict'>
print(type(empty_dict))  # <class 'dict'>
```

Otra forma de crear un diccionario es usar el `dict`constructor.

```python
another_empty_dict = dict()  # using the dict constructor

print(type(another_empty_dict))  # <class 'dict'>
```

Al crear un diccionario no vacío, un constructor de dict puede tomar un diccionario como argumento y / o claves de diccionario futuras como argumentos con valores asignados, como en el ejemplo:

```python
# note that the future dictionary keys are listed without quotes
prices_with_constr = dict({'espresso': 5.0}, americano=8.0, latte=10, pastry='various prices')

print(prices_with_constr)  # {'espresso': 5.0, 'americano': 8.0, 'latte': 10, 'pastry': 'various prices'}
```

Cuando le damos al dict constructor las claves del diccionario con valores asignados, as `dict(americano=8.0)`, la parte izquierda de la expresión se trata como una variable. A diferencia del uso de llaves, en las que puede usar números enteros como claves, las claves en el constructor dict no pueden ser un número entero, una cadena entre comillas, una lista, una expresión de varias palabras, etc. Es decir, las siguientes líneas te dará un error:

```python
d1 = dict(888=8.0)
d2 = dict("americano"=8.0)
d3 = dict(["americano", "filter"]=8.0)
d4 = dict(the best americano=8.0)
```



En general, las llaves y el constructor dict son intercambiables, solo tenga en cuenta la característica dada anteriormente.



Por último, puede crear un diccionario anidado. Es una colección de diccionarios dentro de un solo diccionario.

```python
# a nested dictionary example
my_pets = {'dog': {'name': 'Dolly', 'breed': 'collie'},
           'cat': {'name': 'Fluffy', 'breed': 'maine coon'}}

# another nested dictionary example
# note that keys of the outer dictionary are numbers
digits = {1: {'Word': 'one', 'Roman': 'I'}, 
          2: {'Word': 'two', 'Roman': 'II'}, 
          3: {'Word': 'three', 'Roman': 'III'}, 
          4: {'Word': 'four', 'Roman': 'IV'}, 
          5: {'Word': 'five', 'Roman': 'V'}}
```

##### Accediendo a los artículos

La sintaxis para **acceder a** un elemento es bastante simple: corchetes `[]`con una clave entre ellos. Este enfoque funciona tanto para agregar objetos a un diccionario como para leerlos desde allí:

```python
my_pet = {}

# add 3 keys and their values into the dictionary
my_pet['name'] = 'Dolly'
my_pet['animal'] = 'dog'
my_pet['breed'] = 'collie'

print(my_pet)  # {'name': 'Dolly', 'animal': 'dog', 'breed': 'collie'}

# get information from the dictionary about an added item
print(my_pet['name'])  # Dolly
```

Cuando se trabaja con un diccionario anidado, obtener el valor correcto puede ser un poco más difícil. Como en nuestro ejemplo, hay diferentes niveles y debe detenerse a la profundidad adecuada.

```python
# our nested dictionary once again:
my_pets = {'dog': {'name': 'Dolly', 'breed': 'collie'},
           'cat': {'name': 'Fluffy', 'breed': 'maine coon'}}

print(my_pets['cat'])  # {'name': 'Fluffy', 'breed': 'maine coon'}

print(my_pets['cat']['breed'])  # maine coon
```

##### Elegir las llaves

Puede guardar objetos de cualquier tipo en un diccionario, pero no todos califican como clave. Necesita una clave buena y **única** para cada objeto de su colección. Aún así, esta no es la única restricción en las claves del diccionario y las cubriremos más adelante. Por ahora, use números y cadenas de forma segura.

Cuando ya se haya agregado una clave a su diccionario, se sobrescribirá su valor anterior:

```python
trilogy = {'IV': 'Star Wars', 'V': 'The Empire Strikes Back', 'VI': 'Return of the Jedi'}
print(trilogy['IV'])  # Star Wars

trilogy['IV'] = 'A New Hope'
print(trilogy['IV'])  # A New Hope
```

En **Python 3.7 y** versiones **posteriores** , los diccionarios mantienen el **orden de inserción** de los valores que almacenan, pero en versiones anteriores no es necesariamente así:

```python
alphabet = {}
alphabet['alpha'] = 1
alphabet['beta'] = 2

print(alphabet)
# Python 3.8 output: {'alpha': 1, 'beta': 2}
```

##### Resumen

En este tema, hemos cubierto algunos conceptos básicos para el tipo de datos de **diccionario** en Python:

- cómo crear un diccionario,
- que es un diccionario anidado,
- cómo administrar los elementos del diccionario: claves y valores.

En la siguiente lección, se familiarizará con las operaciones básicas de los diccionarios, pero primero, practiquemos algunas tareas para que se sienta seguro al usar este tipo de datos.

```python
# create a dict here
favorite_flowers = {'Alex': 'field flowers',
                    'Kate': 'daffodil',
                    'Eva': 'artichoke flower',
                    'Daniel': 'tulip'}
# and print it
print(favorite_flowers)

				### MEJOR OPCION ###

favorite_flowers = {'Alex': 'field flowers',
                    'Kate': 'daffodil',
                    'Eva': 'artichoke flower',
                    'Daniel': 'tulip'}

for key,value in favorite_flowers.items():
    print(f'{key}-> {value}')
```

#### Cambiar un valor de un diccionario

```python
shopping_list = {'bananas': 5, 'oranges': 3, 'yogurt': 2, 'chicken breasts': 3, 'olive oil': 1}
###---###
shopping_list['bananas'] = 10
```





# Teoría: Argumentos

A estas alturas, estás en buenos términos con las funciones, ya que sabes cómo invocarlas y declararlas. Profundicemos un poco su conocimiento y descubramos algunas características nuevas de funciones.

Primero, se debe trazar una línea entre los términos **"argumento"** y **"parámetro"** . Los parámetros representan lo que acepta una función, son esos nombres los que aparecen en la definición de la función. Mientras tanto, los argumentos son los valores que le pasamos a una función cuando la llamamos. Cubriremos más tanto los argumentos como los parámetros.

##### Argumentos posicionales

Hay diferentes formas de asignar argumentos a una función. En primer lugar, puede hacerlo simplemente por **posición** . En este caso, los valores se asociarán con los parámetros en el orden en que los pasó a su función **de izquierda a derecha** . Estos argumentos se denominan **posicionales** o **no palabras clave** .

```python
def subtract(x, y):
    return x - y


subtract(11, 4)  # 7
subtract(4, 11)  # -7
```

Cuando intercambiamos los números en la segunda llamada de función, obtuvimos un resultado diferente. Por lo tanto, puede ver que el orden determina cómo se asignan los argumentos.

##### Argumentos nombrados

Otra forma de asignar argumentos es por **nombre** . A veces, es posible que desee controlar el orden de los valores pasados. Ahí es donde entran en juego los argumentos con **nombre** o **palabra clave** .

```python
def greet(name, surname):
    print("Hello,", name, surname)


# Non-keyword arguments
greet("Willy", "Wonka")               # Hello, Willy Wonka

# Keyword arguments
greet(surname="Wonka", name="Willy")  # Hello, Willy Wonka
```

El orden no importa aquí ya que los parámetros se hacen coincidir por nombre. Sin embargo, los argumentos de palabras clave siempre se escriben **después de** los argumentos que no son palabras clave cuando se llama a una función:

```python
greet("Frodo", surname="Baggins")  # Hello, Frodo Baggins
greet(name="Frodo", "Baggins")     # SyntaxError: positional argument follows keyword argument
```

Asegúrese de mencionar cada parámetro **una vez** . Para entender por qué esto es importante, pensemos en lo que sucede cada vez que llamamos a una función. De hecho, los argumentos se inicializan para que todas las operaciones con los valores de esta función comiencen desde cero. No puede inicializar un argumento dos veces, por lo que si ya se ha pasado un valor y se ha asociado con algún parámetro, los intentos de asignar otro valor a este nombre fallarán.

```python
def greet(name, surname):
    print("Hello,", name, surname)


greet("Clementine", name="Rose")
# TypeError: greet() got multiple values for argument 'name'
```

Como se muestra en el ejemplo, varios valores para el mismo nombre provocan un error.

##### Los nombres son importantes

Hemos cubierto los principales errores que puede enfrentar. Por supuesto, puede haber más parámetros en una función:

```python
def responsibility(developer, tester, project_manager, designer):
    print(developer, "writes code")
    print(tester, "tests the system")
    print(project_manager, "manages the product")
    print(designer, "develops design")
```

Tenga en cuenta que cuando usamos argumentos de palabras clave, los nombres son importantes, no las posiciones. Por tanto, el siguiente ejemplo funcionará correctamente:

```python
responsibility(project_manager="Sara", developer="Abdul", tester="Yana", designer="Mark")
# Abdul writes code
# Yana tests the system
# Sara manages the product
# Mark develops design
```

Sin embargo, si llamamos a la función con el mismo orden de nombres, pero sin argumentos con nombre, la salida será incorrecta, con responsabilidades mixtas:

```python
responsibility("Sara", "Abdul", "Yana", "Mark")
# Sara writes code
# Abdul tests the system
# Yana manages the product
# Mark develops design
```

De esta forma, Python conoce los nombres de los argumentos que toma nuestra función. Podemos pedir que nos los recuerden usando la `help()`función incorporada.

```python
help(responsibility)
# Help on function responsibility in module __main__:
# responsibility(developer, tester, project_manager, designer)
```

##### Tiempo de PEP

Mira las llamadas de función y función declarada mostrados en este tema una vez más: `greet(name="Willy", surname="Wonka")`. ¿Ha notado que faltan espacios alrededor del letrero de igualdad? Su ausencia no es accidental. Según la [convención de PEP 8](https://www.python.org/dev/peps/pep-0008/#other-recommendations) , no debe poner espacios alrededor `=`al indicar un argumento de palabra clave.

##### Resumen

Ahora que hemos discutido algunas características avanzadas de las funciones, resumamos:

- Hay una distinción entre **parámetros** y **argumentos** .
- Puede pasar argumentos a una función por **posición** y por **nombre** .
- El **orden** de los **parámetros** declarados es importante, así como el **orden de los argumentos** pasados a una función.
- La `help()`función puede decirle los **argumentos de** la **función** por nombre.

> Los parámetros aparecen en la definición de una función, mientras que los argumentos son los valores que pasamos durante una llamada.

```python
def greeting(first_name, second_name):
   print("Hello,", first_name, "and", second_name) 

name_1 = input()
name_2 = input()

greeting(first_name=name_1,second_name=name_2)
### OTRA OPCION
greeting(name_1,name_2)
greeting(name_2,name_1)

### Agregar un valor a una funcion determinda
add_book(title='Alvion')
```



# Teoría: Operaciones con lista

Ya sabe cómo crear listas (incluso las vacías), por lo que, no es de extrañar, es posible que desee cambiar sus listas de alguna manera. Hay muchas cosas que hacer con una lista, puede leer sobre ellas en la [documentación de Python Data Structures](https://docs.python.org/3/tutorial/datastructures.html) . En este tema, discutiremos solo las operaciones básicas.

##### Agregar un elemento

La lista es una **colección dinámica** , lo que significa que puede agregar y eliminar elementos. Para echar un vistazo más de cerca, creemos una lista vacía de dragones.

```python
dragons = []  # we do not have dragons yet
```

¿Lo que sigue? Lo primero que me viene a la mente es, por supuesto, **agregar nuevos elementos** a la lista.

Para agregar un nuevo elemento al final de una lista existente, debe usar el `list.append(element)`método. Solo necesita un único argumento, por lo que de esta manera puede agregar solo un elemento a la lista a la vez.

```python
dragons.append('Rudror')
dragons.append('Targiss')
dragons.append('Coporth')
```

Ahora tienes tres dragones, y están ordenados de la forma en que los agregaste:

```python
print(dragons)  # ['Rudror', 'Targiss', 'Coporth']
```

##### Añadiendo varios elementos

Existe la `list.extend(another_list)`operación que agrega todos los elementos de otro iterable al final de una lista.

```python
numbers = [1, 2, 3, 4, 5]
numbers.extend([10, 20, 30])
print(numbers)  # [1, 2, 3, 4, 5, 10, 20, 30]
```

Tenga cuidado: si usa en `list.append(another_list)`lugar de `list.extend(another_list)`, agrega la lista completa como un elemento:

```python
numbers = [1, 2, 3, 4, 5]
numbers.append([10, 20, 30])
print(numbers)  # [1, 2, 3, 4, 5, [10, 20, 30]]
```

Alternativamente, para fusionar dos listas, puede agregar una a otra:

```python
numbers_to_four = [0, 1, 2, 3, 4]
numbers_from_five = [5, 6, 7, 8, 9]
numbers = numbers_to_four + numbers_from_five 
print(numbers)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Si necesita una lista con elementos repetidos, puede crear una lista con el patrón repetido y luego simplemente multiplicarla por cualquier número. Esto es particularmente útil cuando desea crear una lista de una longitud específica con el mismo valor:

```python
pattern = ['a', 'b', 'c']
patterns = pattern * 3
print(patterns)  # ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']

one = [1]
ones = one * 7
print(ones)  # [1, 1, 1, 1, 1, 1, 1]
```

##### Eliminar elementos

Lo contrario de agregar elementos, **eliminarlos** , se puede hacer de tres maneras. Echemos un vistazo a ellos.

Primero, podemos usar la `list.remove(element)`operación.

```python
dragons.remove('Targiss')
print(dragons)  # ['Rudror', 'Coporth']
```

Si el elemento que queremos eliminar aparece varias veces en la lista, solo se elimina la primera instancia de ese elemento.

```python
dragons = ['Rudror', 'Targiss', 'Coporth', 'Targiss']
dragons.remove('Targiss')
print(dragons)  # ['Rudror', 'Coporth', 'Targiss']
```

Las otras dos formas eliminan elementos por sus **índices en** lugar de los valores mismos. La `del`palabra clave elimina cualquier tipo de objeto en Python, por lo que se puede usar para eliminar elementos específicos en una lista:

```python
dragons = ['Rudror', 'Targiss', 'Coporth']
del dragons[1]
print(dragons)  # ['Rudror', 'Coporth']
```

Finalmente, está el `list.pop()`método. Si se usa sin argumentos, elimina y devuelve **el último elemento** de la lista.

```python
dragons = ['Rudror', 'Targiss', 'Coporth']
last_dragon = dragons.pop()
print(last_dragon)  # 'Coporth'
print(dragons)      # ['Rudror', 'Targiss']
```

Alternativamente, podemos especificar el índice del elemento que queremos eliminar y devolver:

```python
dragons = ['Rudror', 'Targiss', 'Coporth']
first_dragon = dragons.pop(0)
print(first_dragon)  # 'Rudror'
print(dragons)       # ['Targiss', 'Coporth']
```

##### Insertar elementos en una posición específica

Al comienzo de este tema, hemos aprendido cómo agregar nuevos elementos al final de una lista. Si queremos agregar un nuevo elemento en el medio, usamos la `list.insert(position, element)`operación. El primer argumento es el índice del elemento **antes del** cual se va a insertar el nuevo elemento; por lo que `list.insert(0, element)`inserta un elemento al principio de la lista y `list.insert(len(list), element)`es completamente similar a `list.append(element)`.

Aquí hay un ejemplo:

```python
years = [2016, 2018, 2019]
years.insert(1, 2017)           # [2016, 2017, 2018, 2019]
years.insert(0, 2015)           # [2015, 2016, 2017, 2018, 2019]
years.insert(len(years), 2020)  # [2015, 2016, 2017, 2018, 2019, 2020]
```

¡Ahora puedes llenar cualquier lista vacía con algo útil!

##### Prueba de membresía en una lista

Otra cosa que puede resultar muy útil es comprobar si un elemento está presente en la lista. Se puede hacer simplemente usando los operadores `in`y `not in`:

```python
catalog = ['yogurt', 'apples', 'oranges', 'bananas', 'milk', 'cheese']
 
print('bananas' in catalog)      # True
 
product = 'lemon'
print(product in catalog)        # False
print(product not in catalog)    # True
```

##### Buscando elementos específicos

A veces, saber que el elemento especificado está en la lista no es suficiente; es posible que deseemos obtener más información al respecto: cuántas veces aparece el elemento en la lista y en qué posición.

El método `count()`puede ayudar con la cantidad:

```python
grades = [10, 5, 7, 9, 5, 10, 9]
print(grades.count(5))  # 2
```

Podemos usar el método `index() `para obtener la posición del elemento. Encuentra el índice de la **primera aparición** del elemento en la lista:

```python
print(grades.index(7))   # 2
print(grades.index(10))  # 0
```

También podemos especificar el intervalo de búsqueda: `list.index(element, start, end)`.

```python
print(grades.index(9, 2, 5))  # 3

# if we don't specify the end of the interval, it automatically equals the end of the list
print(grades.index(10, 1))    # 5
```



Tenga cuidado: el `end`índice no está incluido en el intervalo.



También es bueno saber que si el elemento que buscamos no está en la lista, el método provocará un **error** :

```python
print(grades.index(8))  # ValueError: 8 is not in list
```

Nuestra discusión sobre las operaciones básicas con listas ha llegado a su fin. Si necesita más información, consulte la [documentación de Python Data Structures](http://docs.python.org/3/tutorial/datastructures.html) .

##### Resumen

Resumiendo, en este tema hemos aprendido a:

- agregar un elemento con `append()`;

- agregue varios elementos con `extend()`;

- eliminar elementos con `remove()`;

- insertar un elemento en una posición especificada con `insert()`;

- compruebe si un elemento está en una lista o no con los operadores `in`y `not in`;

- contar cuántas veces aparece un elemento en una lista con `count()`;

- obtener la posición de un elemento en una lista con `index()`.

    También sabemos ahora que, dado que la lista es una colección dinámica, se puede cambiar. No es necesario crear constantemente nuevas listas, lo que beneficia la memoria y el rendimiento de su programa.		



```python
def merge_lists(list_one, list_two):
	list_one.extend(list_two)
	return list_one

l1 = ['Washington, D.C.', 'Chicago', 'New York']
l2 = ['Los Angeles', 'Las Vegas']
l3 = merge_lists(list_one=l1 , list_two=l2)
print(l3)
```

```python
numbers = [2, 2, 4, 1, 1, 3, 5]


numbers.remove(1)
numbers.extend([0])
numbers.append(len(numbers))
numbers.remove(5)
numbers.append(5)
print(numbers)

[2, 2, 4, 1, 3, 0, 7, 5]
```



# Teoría: Tupla

A estas alturas, definitivamente sabe cómo manejar una lista, la colección más popular en Python. Ahora descubramos un tipo de datos igualmente útil: las **tuplas** . Debe recordar que son casi idénticas a las listas. Lo que los distingue es su **inmutabilidad** .

##### Definir una tupla

Dado que las tuplas no se pueden cambiar, la creación de tuplas es similar a abrir una caja de un tamaño fijo, luego poner varios valores en esta caja y sellarla. Una vez sellada la caja, no se puede modificar su tamaño ni su contenido.

Utilice un par de **paréntesis** para definir una tupla:

```python
empty_tuple = ()
print(type(empty_tuple))  # <class 'tuple'>
```

Las tuplas vacías son fáciles de crear. Entonces, ¿qué salió mal en el siguiente ejemplo?

```python
not_a_tuple = ('cat')
print(not_a_tuple)        # 'cat'
print(type(not_a_tuple))  # <class 'str'>
```

Como puede ver, la variable que creamos almacena una cadena. En realidad, es una **coma** que forma una tupla, no un paréntesis. Arreglemos este fragmento de código:

```python
now_a_tuple = ('cat',)
print(now_a_tuple)        # ('cat',)
print(type(now_a_tuple))  # <class 'tuple'>
```

Por lo tanto, siempre use una coma al definir una tupla singleton. De hecho, incluso si su tupla contiene más de un elemento, separar los elementos con comas será suficiente:

```python
weekend = 'Saturday', 'Sunday'
print(weekend)        # ('Saturday', 'Sunday')
print(type(weekend))  # <class 'tuple'>
```

La función incorporada `tuple()`convierte cadenas, listas y otros **iterables** en una tupla. Con esta función, también puede crear una tupla vacía.

```python
# another empty tuple
empty_tuple = tuple()
print(empty_tuple)        # ()
print(type(empty_tuple))  # <class 'tuple'>

# a list turned into a tuple
bakers_dozen = tuple([12, 1])
print(bakers_dozen == (12, 1))  # True

# a tuple from a string
sound = tuple('meow')
print(sound)  # ('m', 'e', 'o', 'w')
```

##### ¿Qué podemos hacer con las tuplas?

Primero, examinemos qué características tienen en común las listas y las tuplas.

Tanto las listas como las tuplas están **ordenadas** , es decir, al pasar elementos a estos contenedores, puede esperar que su orden siga siendo el mismo. Las tuplas también son indiferentes a la naturaleza de los datos almacenados en ellas, por lo que puede **duplicar valores** o **mezclar diferentes tipos de datos** :

```python
tiny_tuple = (0, 1, 0, 'panda', 'sloth')

print(len(tiny_tuple))  # 5
print(tiny_tuple)       # (0, 1, 0, 'panda', 'sloth')
```

Al igual que las listas, las tuplas admiten la **indexación** . Sin embargo, tenga cuidado con los índices si quiere arreglárselas sin ellos `IndexErrors`.

```python
empty_tuple = ()
print(empty_tuple[0])  # IndexError

numbers = (0, 1, 2)
print(numbers[0])   # 0
print(numbers[1])   # 1
print(numbers[2])   # 2
print(numbers[3])   # IndexError
```

Y aquí entra en juego la primera característica distintiva de las tuplas. Lo que no admiten es la **asignación de elementos** . Si bien puede cambiar un elemento en una lista que hace referencia a este elemento por su índice, no es el caso de las tuplas:

```python
# ex-capitals
capitals = ['Philadelphia', 'Rio de Janeiro', 'Saint Petersburg']

capitals[0] = 'Washington, D.C.'
capitals[1] = 'Brasília'
capitals[2] = 'Moscow'
print(capitals)  # ['Washington, D.C.', 'Brasília', 'Moscow']

former_capitals = tuple(capitals)
former_capitals[0] = 'Washington, D.C.'  # TypeError
```

En el ejemplo anterior, intentamos actualizar la tupla y no terminó bien. No puede agregar un elemento a una tupla o eliminarlo de allí (a menos que elimine toda la tupla). Sin embargo, la inmutabilidad tiene un lado positivo. Lo discutiremos en la siguiente sección.

##### Inmutabilidad y sus ventajas.

En este momento, es posible que se le haya ocurrido una pregunta: ¿por qué usar tuplas cuando tenemos listas? Como era de esperar, todas las respuestas conducen a la inmutabilidad. Detengámonos en sus ventajas:

- Las tuplas son **más rápidas** y **eficientes en memoria** que las listas. Siempre que necesite trabajar con grandes cantidades de datos, debe pensarlo. Si no va a modificar sus datos, tal vez debería optar por tuplas.
- Una tupla se puede utilizar como **clave de diccionario** , mientras que las listas como claves darán como resultado `TypeError`.
- Por último, pero no menos importante, es **imposible cambiar** por accidente los datos almacenados en una tupla. Puede resultar una solución segura y sólida para algunas tareas.

##### Resumen

Esos eran los conceptos básicos de las tuplas en Python. Al igual que las listas, las tuplas están **ordenadas** y son **iterables** . A diferencia de las listas, son **inmutables** . Aprenderá más sobre las características de tuplas en los siguientes temas, ¡ahora es el momento de escribir sus primeros programas con ellas!

# Teoría: declaración If

Hay situaciones en las que su programa necesita ejecutar algún fragmento de código solo si una condición particular es verdadera. Es posible establecer esa condición en Python y, en este tema, ¡aprenderemos cómo!

##### Declaración if simple

Entonces, en Python, un fragmento de código que debe ejecutarse solo bajo alguna condición debe colocarse dentro del cuerpo de una **declaración if** . El patrón es el mismo que en el idioma inglés: primero viene la palabra clave **`if`**, luego una condición y luego una lista de expresiones para ejecutar. La condición es siempre una **expresión booleana** , es decir, su valor es igual a `True`o `False`. Aquí hay un ejemplo de cómo debería verse el código con una expresión condicional:

```python
biscuits = 17
if biscuits >= 5:
    print("It's time for tea!")
```

Tenga en cuenta que la condición termina con dos puntos y una nueva línea comienza con una **sangría** . Por lo general, se utilizan 4 espacios para designar cada nivel de sangría. Un fragmento de código en el que todas las líneas están en el mismo nivel de sangría se denomina **bloque de código** . En Python, *solo* se usa sangría para separar diferentes bloques de código, por lo tanto, solo la sangría muestra qué líneas de código se supone que deben ejecutarse cuando `if`se satisface la declaración y cuáles deben ejecutarse *independientemente* de la `if`declaración. Mira el siguiente ejemplo:

```python
if biscuits >= 5:
    print("It's time for tea!")
    print("What tea do you prefer?")
print("What about some chocolate?")
```

En este ejemplo, la línea `"It's time for tea!"`, así como `"What tea do you prefer?`", se imprimirán solo si hay 5 o más galletas. La línea `"What about some chocolate?"`se imprimirá independientemente del número de galletas.

Una `if` declaración se ejecuta solo si su condición se cumple (el valor booleano es `True`); de lo contrario, se omite.

Los valores booleanos básicamente dejan claro si un fragmento de código debe ejecutarse o no. Dado que las comparaciones dan como resultado `bool`, siempre es una buena idea usarlas como condición.



Sin embargo, hay una trampa. No debe confundir el operador de comparación para la igualdad `==`con el operador de asignación `=`. Solo el primero proporciona una condición adecuada. Intente evitar este error común en su código.



##### Instrucción if anidada

A veces, una condición resulta ser demasiado complicada para una simple `if`afirmación. En este caso, puede utilizar las llamadas declaraciones **anidadas**`if` . Cuantas más `if`declaraciones se aniden, más complejo se vuelve su código, lo que generalmente no es algo bueno. Sin embargo, esto no significa que deba evitar las `if`declaraciones anidadas a toda costa. Echemos un vistazo al siguiente código:

```python
rainbow = "red, orange, yellow, green, blue, indigo, violet"
warm_colors = "red, yellow, orange"
my_color = "orange"

if my_color in rainbow:
    print("Wow, your color is in the rainbow!")
    if my_color in warm_colors:
        print("Oh, by the way, it's a warm color.")
```

El ejemplo anterior ilustra una `if`declaración anidada . Si la variable `my_color`es una cadena que contiene el nombre de un color del arco iris, ingresamos el cuerpo de la primera `if` declaración. Primero imprimimos el mensaje y luego comprobamos si nuestro color pertenece a los colores cálidos. El operador de membresía `in`simplemente muestra si `my_color`es una subcadena de la cadena respectiva, `rainbow`o `warm_colors`. Al igual que las comparaciones aritméticas, devuelve un valor booleano.

Esto es lo que veremos en nuestro caso:

```no-highlight
Wow, your color is in the rainbow!
Oh, by the way, it's a warm color.
```

Cuando se trata de `if`declaraciones anidadas , la sangría adecuada es crucial, así que no olvide aplicar sangría a cada declaración que comience con la `if`palabra clave.

##### Resumen

En resumen, en este tema, hemos aprendido cómo escribir y anidar condiciones en Python con if-statement.



# Teoría: otra declaración

Establecer condiciones es una herramienta muy popular y útil en programación. Sin embargo, a veces, comprobar si una condición es verdadera o no puede no ser suficiente. Digamos que no desea que se ejecute un fragmento de código si su condición es falsa, pero, si ese es el caso, hay otro fragmento de código que desea ejecutar. Para situaciones como esta, Python tiene otra herramienta poderosa sobre la cual aprenderemos en este tema.

##### Simple if-else

Una **declaración if-else** es otro tipo de expresiones condicionales en Python. Se diferencia de una **instrucción if** por la presencia de la palabra clave adicional `else`. El bloque de código que `else`contiene se ejecuta cuando la condición de su declaración if no se cumple (el valor booleano es `False`). Dado que una instrucción else es una alternativa para una instrucción if, solo se puede ejecutar un bloque de código. Además, `else`no requiere ninguna condición:

```python
if today == "holiday":
    print("Lucky you!")
else:
    print("Keep your chin up, then.")
```

Tenga en cuenta que aquí también se aplica la regla de **sangría de** 4 espacios .

Como pronto descubrirá, a los programadores les gustan todo tipo de atajos. Para las expresiones condicionales, también hay un truco: puede escribir una declaración if-else en una línea. Esto se llama **operador ternario** y tiene este aspecto:

```python
print("It’s a day now!" if sun else "It’s a night for sure!")
```

O, de manera más general:

```python
first_alternative if condition else second_alternative
```

Es una cuestión de conveniencia, pero recuerde que el código que cree debe ser legible.

##### If-else anidado

Cabe mencionar que las `if-else`declaraciones se pueden **anidar de** la misma manera que las `if`declaraciones. Puede aparecer una expresión condicional adicional después de la `if`sección, así como después de la `else`sección. Una vez más, no olvide aplicar la sangría correctamente:

```python
if x < 100:
    print('x < 100')
else:
    if x == 100:
        print('x = 100')
    else:
        print('x > 100')
    print('This will be printed only because x >= 100')
```

##### Resumen

En este tema, hemos aprendido sobre un tipo más de expresión condicional: instrucción if-else. Repasemos los puntos principales nuevamente:

- la palabra clave `else`se usa para dar una alternativa;
- se ejecutará en caso de que la `if`declaración no lo sea;
- no requiere ninguna condición;
- `if-else` Las declaraciones se pueden anidar.

¡Eso es todo! Ahora está listo no solo para establecer condiciones, sino también para considerar diferentes alternativas. ¡Felicidades!

```python
dictionary = ["aa", "abab", "aac", "ba", "bac", "baba", "cac", "caac"]
if input() in dictionary:
    print("Correct")
else:
    print("Incorrect")
    
 ###----####   
city = "..."
summer = "Barcelona, Rome, Istanbul, Lisbon, Paris"
winter = "Oslo, Helsinki, Sydney, Cape Town, Vienna"

if (city in summer) or (city in winter):
    if city in summer:
        print("You should visit it in the summer!")
    else:
        print("You should visit it in the winter!")
else:
    print("I don't know what the best season is :(")
```

```python
Here's a piece of a program that tells you when it is best to visit a particular city:

city = "..."
summer = "Barcelona, Rome, Istanbul, Lisbon, Paris"
winter = "Oslo, Helsinki, Sydney, Cape Town, Vienna"

if (city in summer) or (city in winter):
    if city in summer:
        print("You should visit it in the summer!")
    else:
        print("You should visit it in the winter!")
else:
    print("I don't know what the best season is :(")
Match the value of city with the program's response.
```



# Teoría: declaración de Elif

Ya que está familiarizado con las declaraciones condicionales básicas, como la declaración **if** y la declaración **if-else** , es hora de la **declaración elif** más avanzada .

**La declaración Elif** se usa cuando queremos especificar varias condiciones en nuestro código. ¿En qué se diferencia de **las declaraciones if-else** ? Bueno, es simple. Aquí agregamos la palabra clave **elif** para nuestras condiciones adicionales. Se usa principalmente con operadores if y else y la sintaxis básica se ve así:

```python
# basic elif syntax
if condition1:
    action1
elif condition2:
    action2
else:
    action3
```

La condición va seguida de dos puntos, al igual que con las declaraciones **if-else** , la acción deseada se coloca dentro del cuerpo **elif** y no se olvide de una **sangría** , es decir, 4 espacios al comienzo de una nueva línea. Aquí primero verificamos la condición1 en la instrucción **if** y si se cumple (el valor de la expresión booleana es **Verdadero** ), se realiza la acción1. Si es **False** , omitimos action1 y luego verificamos la condition2 en la declaración **elif** . Nuevamente, si condition2 es Verdadero, se realiza action2; de lo contrario, lo omitimos y vamos a la parte **else** del código.

Echemos un vistazo al siguiente ejemplo:

```python
# elif example
price = 10000 # there should be some int value
if price > 5000:
    print("That's too expensive!")
elif price > 500:
    print("I can afford that!")
else:
    print("That's too cheap!")
```

¿Comprar o no comprar? Para responder a la pregunta, primero verificamos si el precio es superior a 5000. Si 'precio> 5000' es Verdadero, imprimimos que es demasiado caro y partimos en busca de algo más barato. Pero, ¿y si el precio fuera inferior a 5000? En este caso, verificamos que la siguiente condición es 'precio> 500', y nuevamente, si es Verdadero, imprimimos que podemos pagarlo, y si es Falso, vamos al bloque **else** e imprimimos que es demasiado barato. Así que "¡me lo puedo permitir!" se imprimirá si el precio es inferior a 5000 pero superior a 500, y "Eso es demasiado barato" si el precio es inferior a 500.

**La** declaración **Elif** difiere de **else** en un momento clave: representa otra opción específica, mientras que **else se** ajusta a todos los casos que no caen en la condición dada en la declaración **if** . Es por eso que a veces puede encontrar declaraciones condicionales sin **más** :

```python
pet = 'cat'  # or 'dog'?

# cats vs dogs conditional
if pet == 'cat':
    print('Oh, you are a cat person. Meow!')
elif pet == 'dog':
    print('Oh, you are a dog person. Woof!')
```

En este ejemplo, es posible agregar una declaración **else** para expandir ligeramente una perspectiva, pero no es necesario si solo estamos interesados en perros y gatos.

##### ¿Por qué elif y no si?

El último ejemplo probablemente le hizo preguntarse: ¿por qué usamos una `elif`declaración en lugar de solo dos `if`declaraciones? ¿No `if`serían más fáciles dos afirmaciones?

```python
if pet == 'cat':
    print('Oh, you are a cat person. Meow!')
if pet == 'dog':
    print('Oh, you are a dog person. Woof!')
```

En este caso particular, el resultado sería el mismo que con `elif`. Pero esto no funcionaría como es necesario para el primer ejemplo de este tema:

```python
price = 6000
if price > 5000:
    print("That's too expensive!")
if price > 500:
    print("I can afford that!")
else:
    print("That's too cheap!")
# The output is 'That's too expensive!\nI can afford that!'
```

¿Ver? Recibimos dos mensajes contradictorios en lugar de uno que originalmente teníamos la intención de mostrar. La diferencia entre los ejemplos anteriores es que en el ejemplo con mascotas, los casos descritos por declaraciones condicionales son *mutuamente excluyentes* , es decir, no hay una cadena que sea igual `'dog'`y `'cat'`al mismo tiempo. En el otro ejemplo, los casos no son mutuamente excluyentes y hay valores para `price`que pueden satisfacer ambas condiciones.

Por lo tanto, la `elif`declaración es una mejor alternativa que dos `if`declaraciones cuando desea mostrar que se supone que solo se cumple una de las condiciones. Una cadena de `if`declaraciones implica que las condiciones expresadas en ellas no están relacionadas en absoluto y pueden satisfacerse independientemente unas de otras, como en el siguiente ejemplo:

```python
animal = 'unicorn'
if animal in 'crow, dog, frog, pony':
    print('This animal exists')
if animal in 'unicorn, pegasus, pony':
    print('This animal is a horse')
```

Con esta distinción en mente, podrá hacer que su código sea más claro y menos propenso a errores. Ahora, volvamos a estudiar la `elif`funcionalidad.

##### Múltiples elif y un árbol de decisiones

Puede haber tantas declaraciones **elif** como necesite, por lo que sus condiciones pueden ser muy detalladas. No importa cuántas declaraciones **elif** tenga, la sintaxis es siempre la misma. La única diferencia es que agregamos más **elifs** :

```python
# multiple elifs syntax
if condition1:
    action1
elif condition2:
    action2
# here you can add as many elifs as you need
elif conditionN:
    actionN
else:
    actionN1
```

El código dentro del bloque **else** se ejecuta solo si todas las condiciones anteriores son **falsas** . Vea el siguiente ejemplo:

```python
# multiple elifs example
light = "red"  # there can be any other color
if light == "green":
    print("You can go!")
elif light == "yellow":
    print("Get ready!")
elif light == "red":
    print("Just wait.")
else:
    print("No such traffic light color, do whatever you want")
```

En este programa, el mensaje del bloque **else** se imprime para la luz de cualquier color excepto verde, amarillo y rojo para los que hemos escrito mensajes especiales.

Los condicionales con múltiples ramas forman un **árbol de decisión** , en el que un nodo es una expresión booleana y las ramas se marcan con **Verdadero** o **Falso** . La rama marcada como Verdadero conduce a la acción que debe ejecutarse y la rama Falsa conduce a la siguiente condición. La siguiente imagen muestra un árbol de decisiones de este tipo de nuestro ejemplo con semáforos.

![img](https://ucarecdn.com/8f7d80be-494d-4599-85a9-c917d5b77cf7/)

##### Declaraciones elif anidadas

Las declaraciones Elif también se pueden **anidar** , al igual **que las** declaraciones **if-else** . Podemos reescribir nuestro ejemplo de semáforos con condicionales anidados:

```python
# nested elifs example
traffic_lights = "green, yellow, red"
# a string with one color
light = "purple"  # variable for color name
if light in traffic_lights:
    if light == "green":
        print("You can go!")
    elif light == "yellow":
        print("Get ready!")
    else:
        # if the lights are red
        print("Just wait.")
else:
    print("No such traffic light color, do whatever you want")
```

##### Resumen

En este tema, nos familiarizamos con elif-statement y aprendimos cuándo podría ser útil, cómo usarlo y anidarlo o hacer un árbol de decisiones con él. Ya que domina el tema de los condicionales, ¡a partir de ahora puede hacer que su programa haga lo que quiera cuando quiera!

Let's imagine a chessboard, the squares on which are marked with coordinates. The coordinates are numbers between 1 and 8 inclusively. The first number indicates a column, the second one indicates a row.

![img](https://ucarecdn.com/cbd97f5f-f89c-47d8-82e9-82de3b752632/)

The chess king can stand on any square and can move one step horizontally, vertically, or diagonally in any direction within the board.

The input will contain the coordinates on which the king is located. You should figure out and print how many moves the figure can make: for example, from the position (1, 8), the king can make only 3 moves (right, down, diagonally).

```python
chessExt = ['11','18','81','88']
chessLinExt = ['12','13','14','15',
               '16','17','82','83',
               '84','85','86','87',
               '71','61','51','41',
               '31','21','78','68',
               '58','48','38','28']

x = input()
y = input()
z = x+y
if z in chessExt:
	print(3)
elif z in chessLinExt:
	print(5)
elif z not in chessExt and z not in chessLinExt:
	z = int(z)
	if z<88:
		print(8)
else:
	print('Error Value Chess')
    
    ### Other ###
    arr = [
    [3, 5, 5, 5, 5, 5, 5, 3],
    [5, 8, 8, 8, 8, 8, 8, 5],
    [5, 8, 8, 8, 8, 8, 8, 5],
    [5, 8, 8, 8, 8, 8, 8, 5],
    [5, 8, 8, 8, 8, 8, 8, 5],
    [5, 8, 8, 8, 8, 8, 8, 5],
    [5, 8, 8, 8, 8, 8, 8, 5],
    [3, 5, 5, 5, 5, 5, 5, 3]]

print(arr[int(input()) - 1][int(input()) - 1])

```

```python
chicken = 23
goat = 678
pig = 1296
cow = 3848
sheep = 6769

money = int(input())

if chicken <= money <= goat:
    buy = int(money / chicken)
    if buy > 1:
        print(f'{buy} chickens')
    else:
        print(f'{buy} chicken')
        
elif goat <= money <= pig:
    buy = int(money / goat)
    if buy > 1:
        print(f'{buy} goats')
    else:
        print(f'{buy} goat')
        
elif pig <= money <= cow:
    buy = int(money / pig)
    if buy > 1:
        print(f'{buy} pigs')
    else:
        print(f'{buy} pig')
        
elif cow <= money <= sheep:
    buy = int(money / cow)
    if buy > 1:
        print(f'{buy} cows')
    else:
        print(f'{buy} cow')
        
elif sheep <= money:
    buy = int(money / sheep)
    print(f'{buy} sheep')
else:
    print(None)
    
    
    
    #### OTHER
    
money = int(input())
animal = ["sheep", "cow", "pig", "goat", "chicken"]
animals = ["sheep", "cows", "pigs", "goats", "chickens"]
price = [6769, 3848, 1296, 678, 23]
i = 0
while True:
    if money < price[4]:
        print("None")
        break
    if money >= price[i]:
        amount = money // price[i]
        if amount == 1:
            print(amount, animal[i])
        else:
            print(amount, animals[i])
        break
    i += 1

```

```python
### SHORT CODE
# put your python code here
num_1 = float(input())
num_2 = float(input())
operator = input()

if operator in "/, mod, div":
    if num_2 == 0:
        print("Division by 0!")
    else:
        if operator == "/":
            print(num_1 / num_2)
        elif operator == "mod":
            print(num_1 % num_2)
        else:
            print(num_1 // num_2)
else:
    if operator == "+":
        print(num_1 + num_2)
    elif operator == "-":
        print(num_1 - num_2)
    elif operator == "*":
        print(num_1 * num_2)
    else:
        print(num_1 ** num_2)
### LONGCODE

a = float(input())
b = float(input())

x = input()
if x == '+':
	print(a + b)
elif x == '-':
	print(a - b)
elif x == '/':
	if b != 0:
		print(a / b)
	else:
		print("Division by 0!")
elif x == '*':
	print(a * b)
elif x == 'mod':
	if b != 0:
		print(a % b)
	else:
		print("Division by 0!")
elif x == 'pow':
	print(a ** b)
elif x == 'div':
	if b != 0:
		print(a // b)
	else:
		print("Division by 0!")
```

## Partículas de [declaración](https://hyperskill.org/learn/step/5926) elif

El mundo de las partículas elementales es bastante complejo. Hay muchas clases diferentes y pueden interactuar de una manera bastante interesante.

Dos características importantes de las partículas elementales son el giro y la carga eléctrica. Estas son algunas de las partículas elementales:

| **Partícula** | **Clase** | **Girar** | **Carga eléctrica** |
| ------------- | --------- | --------- | ------------------- |
| Extraño       | Cuarc     | 1/2       | -1/3                |
| Encanto       | Cuarc     | 1/2       | 2/3                 |
| Electrón      | Lepton    | 1/2       | -1                  |
| Neutrino      | Lepton    | 1/2       | 0                   |
| Fotón         | Boson     | 1         | 0                   |

Escribe un programa que devuelva la partícula y su clase en función de su giro y carga eléctrica.

**El formato de entrada:**

Dos líneas: primero el giro de la partícula, luego su carga. Usted *NO* tiene que convertir estos valores a los flotadores.

**El formato de salida:**

La partícula y su clase separadas por un espacio.



# Teoría: Bucle FOR

Las computadoras son conocidas por su capacidad para hacer cosas que la gente considera aburridas y que consumen mucha energía. Por ejemplo, repetir tareas idénticas sin errores es una de estas cosas. En este tema, aprenderemos qué herramienta de Python puede ayudarlo con eso, cómo implementarlo y qué funciones puede usar junto con él.

##### ¿Qué es la iteración?

En Python, el proceso de ejecución repetitiva del mismo bloque de código se denomina **iteración** .

Hay dos tipos de iteración:

**Iteración definida** , donde el número de repeticiones se indica de antemano.

**Iteración indefinida** , donde un bloque de código se ejecuta siempre que la condición establecida de antemano sea verdadera.

Después de la primera iteración, el programa vuelve al principio del cuerpo del código y lo repite, creando un llamado **bucle** . El más utilizado es el `for`**bucle, que** lleva el nombre del `for`**operador** , que proporciona la ejecución del código.

##### Para la sintaxis de bucle

Aquí está el esquema del bucle:

```python
for variable in iterable:
    statement
```

donde `statement`es un bloque de operaciones ejecutadas para cada elemento en **,** un objeto utilizado en iteración (por ejemplo, una cadena o una lista). toma el valor del siguiente iterable después de cada iteración. `iterable``Variable`

Ahora intente adivinar qué resultado obtendremos si ejecutamos el siguiente fragmento de código:

```python
oceans = ['Atlantic', 'Pacific', 'Indian', 'Southern', 'Arctic']
for ocean in oceans:
    print(ocean)
```

Durante cada iteración, el programa tomará los elementos de la lista y ejecutará las declaraciones con ellos, por lo que la salida será:

```python
Atlantic
Pacific
Indian
Southern
Arctic
```

Las cadenas también son iterables, por lo que puede deletrear una palabra, por ejemplo:

```python
for char in 'magic':
    print(char)
```

Como esto:

```python
m
a
g
i
c
```

##### Función de rango

La `range()`**función** se utiliza para especificar el número de iteraciones. Devuelve una secuencia de números desde 0 (por defecto) y termina en un número especificado. Tenga cuidado: el último número no aparecerá en la salida.

Veamos el siguiente ejemplo:

```python
for i in range(5):
    print(i)
```

Lo que obtendremos es esto:

```python
0
1
2
3
4
```

Puede cambiar el **valor inicial** si no está satisfecho con 0, además, puede configurar el valor de **incremento (paso)** agregando un tercer parámetro:

```python
for i in range(5, 45, 10):
    print(i)
```

De acuerdo con los parámetros incluidos, hemos pedido imprimir los números del 5 al 45 con un valor de incremento de 10. Tenga cuidado nuevamente, el último valor no está incluido en la salida:

```python
5
15
25
35
```

Si no va a utilizar la variable de contador en su ciclo, puede mostrarla reemplazando su nombre con el símbolo de subrayado:

```python
for _ in range(100):
    do_smth()
```

En el ejemplo anterior, no necesitamos la variable de contador de ninguna manera, simplemente usamos el ciclo para repetir la `do_smth()`función un número determinado de veces.

##### Procesamiento de datos de entrada

También puede utilizar la `input()`**función,** que ayuda al usuario a pasar un valor a alguna variable y trabajar con ella. Por lo tanto, puede obtener el mismo resultado que con el código anterior:

```python
word = input()
for char in word:
    print(char)
```

Oh, mira, puedes escribir un fragmento de código con un propósito práctico:

```python
times = int(input('How many times should I say "Hello"?'))
for i in range(times):
    print('Hello!')
```

Por lo tanto, puede pedirle al usuario que especifique el número de iteraciones que se realizarán.

##### Bucle anidado

En Python, es fácil colocar un bucle dentro de otro: un **bucle anidado** . El tipo de bucle interno y externo no importa, el primero en ejecutar es el bucle externo, luego el interno se ejecuta:

```python
names = ['Rose', 'Daniel']
surnames = ['Miller']
for name in names:
    for surname in surnames:
         print(name, surname)
```

La salida se muestra a continuación:

```python
Rose Miller
Daniel Miller
```

Consulte [esta](https://pythontutor.com/visualize.html#code=names %3D ['Rose', 'Daniel'] surnames %3D ['Miller'] for name in names%3A    for surname in surnames%3A         print(name, surname)&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=[]&textReferences=false) visualización para comprender mejor cómo funciona el código. En este ejemplo, usamos dos `for`bucles para crear nombres de personas ficticias. Obviamente, puede tratar con objetos iterables de diferentes tamaños sin demasiado alboroto.

##### Resumen

Con todo, los `for`bucles son una forma eficaz de automatizar algunas acciones repetitivas. Puede agregar variables y operaciones para hacer un bucle anidado. Además, puede controlar el número de iteraciones con la ayuda de la `range()`función. Tenga cuidado con la sintaxis: ¡una sangría adicional o la falta de dos puntos pueden causar un error!

```python
phrase = input()
alfabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
character = [phrase[0].lower()]
for char in phrase[1:]:
    if char in alfabet:
        character.append('_')
        character.append(char.lower())
    else:
        character.append(char)
snake_case = ''.join(character)
print(snake_case)
```



# Teoría: descomposición funcional

En este punto, ya sabe cómo declarar funciones en Python. Esta es una habilidad muy útil, sin duda alguna, pero para aprovecharla al máximo, necesitamos saber cuándo declararlos. En este tema, veremos cómo descomponer la solución de un problema particular en funciones.

##### Ejemplo de la vida real

Antes de pasar a la descomposición real, averigüemos qué es lo que queremos descomponer.

Supongamos que estamos escribiendo un programa que simula un cajero automático. ¿Cómo funcionan los cajeros automáticos de la vida real? Bueno, generalmente un cliente inserta la tarjeta, ingresa el pin y, si el pin es correcto, realiza algunas operaciones, por ejemplo, retira dinero o deposita dinero en una cuenta. Podemos reinventar estas acciones como parte de un programa de computadora. Así es como se puede describir el algoritmo en general:

1. Analizar los datos de entrada (tarjeta y pin introducido);
2. Verifique que el pin sea correcto;
3. Pregúntele al cliente qué quiere hacer;
4. Si la operación es compatible, hágalo.

Antes de programar este algoritmo, solucionemos algunas cosas. Obviamente, un banco real tiene una base de datos que almacena todos los datos necesarios, como el PIN correcto cifrado o el saldo actual de la tarjeta. Aquí estamos creando una versión muy simple de un cajero automático, por lo que no vamos a incluir revisiones de la base de datos. En cambio, definiremos variables `card_pin`y `card_balance`. Estas variables representarán el saldo correcto de PIN y tarjeta que hubiéramos obtenido de una base de datos.

También necesitamos determinar qué operaciones permitiremos. Establezcamos tres: mostrar el saldo de la tarjeta, agregar dinero a la cuenta y retirar dinero de la cuenta.

Ahora veamos el código:

```python
# operations
DEPOSIT = "DEPOSIT"
WITHDRAW = "WITHDRAW"
DISPLAY = "DISPLAY"

# read the data
card_number = input("Enter card number: ")
input_pin = input("Enter PIN: ")

# card_pin and card_balance are read from the database

# check that the pin is correct
if card_pin == input_pin:
    # ask the client what they want to do
    action = input("Enter desired action: ")
    if action == DEPOSIT:
        money = float(input("Enter the sum of money to DEPOSIT: "))
        card_balance += money
        print("Deposited: $", money)
        print("Current balance:", card_balance)
    elif action == WITHDRAW:
        money = float(input("Enter the sum of money to WITHDRAW: "))
        card_balance -= money
        print("Withdrawn: $", money)
        print("Current balance:", card_balance)
    elif action == DISPLAY:
        print("Current balance:", card_balance)
    else:
        ...
else:
    print("Incorrect pin!")
```

Como puede ver, están sucediendo muchas cosas y es un poco difícil de seguir. La lógica principal es la misma que describimos anteriormente. Este código funciona perfectamente bien para nuestro problema y podríamos dejarlo así.

Sin embargo, ¿qué pasa si queremos que este script funcione para muchos usuarios y no solo para uno? ¿Qué pasa si queremos procesar otros casos y realizar otras acciones, por ejemplo, comprobar si la tarjeta está en la base de datos o cambiar el pin? Algunas partes de este código serán útiles, otras partes tendremos que comentarlas o eliminarlas. También necesitaríamos realizar un seguimiento de todos los lugares donde estamos introduciendo cambios para asegurarnos de que todo funcione sin problemas. Ahora empieza a sonar como si tuviéramos un problema con nuestro código. La solución, como habrás adivinado, es la descomposición.

##### Descomposición funcional

**La descomposición funcional** es simplemente un proceso de descomposición del problema en varias funciones. Cada función realiza una tarea en particular y podemos realizar estas funciones en una fila para obtener los resultados que necesitamos.

Cuando analizamos un problema, debemos pensar qué acciones queremos repetir varias veces o, alternativamente, realizarlas por separado. Así es como podemos obtener las funciones deseadas. Veamos nuevamente nuestra simulación de cajeros automáticos y descubramos qué pasos se pueden convertir en funciones separadas.

Primero, una acción que hacemos con frecuencia es leer la entrada con un mensaje en particular. En segundo lugar, realizamos una determinada secuencia de acciones cuando el pin es correcto, específicamente preguntamos qué debemos hacer a continuación. En tercer lugar, dependiendo de la respuesta del cliente, realizamos ciertas acciones para depositar la suma en la cuenta o retirarlas de la cuenta. Y por último, sea cual sea la acción, siempre imprimimos el saldo actual.

Algunas de estas acciones se pueden convertir en funciones independientes para simplificar el programa.

Repasemos paso a paso. Primero, separemos nuestras operaciones principales en funciones.

```python
def deposit_money(amount, card_balance):
    """Deposit given amount of money to the account."""
    card_balance += amount
    # save new balance to the database
    return card_balance


def withdraw_money(amount, card_balance):
    """Withdraw given amount of money from the account."""
    card_balance -= amount
    # save new balance to the database
    return card_balance
```

Es posible que haya notado que en el programa original imprimimos el saldo actual independientemente de lo que hayamos hecho antes. Esto significa que también podemos crear una función separada que registraría todo.

```python
def log_transaction(action, money, card_balance):
    if action in (DEPOSIT, WITHDRAW):
        print(action + ": $", money)
    print("Current balance:", card_balance)
```

Esta función se llamará después de que hayamos hecho algo y mostrará información sobre el saldo actual y los cambios que se han realizado.

A continuación, tiene sentido crear una función que administre estas operaciones:

```python
def move_money(action, money, card_balance):
    if action == DEPOSIT:
        return deposit_money(money, card_balance)
    elif action == WITHDRAW:
        return withdraw_money(money, card_balance)
    elif action == DISPLAY:
        return card_balance
```

Puede ver que esta función devuelve el saldo de la tarjeta que obtenemos después de nuestras manipulaciones. Esto es útil porque, como hemos visto antes, siempre queremos saber con cuánto dinero terminamos. Sin embargo, el propósito principal de esta función es simplificar el proceso de revisión de la funcionalidad de nuestro programa. Si queremos agregar alguna otra acción, simplemente agregamos otra opción a la `if - else`declaración y especificamos la función que llevaría a cabo esta tarea. Eliminar es similar.

Una parte importante que aún no hemos cubierto es obtener la información sobre el dinero que trasladaremos a algún lugar. Sabemos que no necesitamos esta información para mostrarla, pero es necesaria para otras operaciones.

```python
def get_amount_of_money(action):
    if action == DISPLAY:
        return 0.0
    money = input("Enter the sum of money to " + action + ": ")
    return float(money)
```

En este momento, solo tenemos fragmentos de nuestro programa final. Otro paso importante es crear una función que lo junte todo.

```python
def make_transaction(action, card_balance):
    money = get_amount_of_money(action)
    card_balance = move_money(action, money, card_balance)
    log_transaction(action, money, card_balance)
```

Aquí es cuando tiene lugar la lógica principal. Tenemos un único punto de entrada que determina el orden de las operaciones y llama a las funciones necesarias.

##### El resultado

Ahora, reescribamos el programa anterior usando estas funciones:

```python
card_number = input("Enter card number: ")
input_pin = input("Enter PIN: ")

# card_pin and card_balance are read from the database

if card_pin == input_pin:
    action = input("Enter desired action: ")
    make_transaction(action, card_balance)
else:
    print("Incorrect pin!")
```

¡Eso es todo! Claro, junto con las funciones, el código es mucho más grande, pero esto nos brinda más ventajas que desventajas. Podemos comprender la dirección general del programa y podemos introducir cambios fácilmente si es necesario. Ahora, por ejemplo, si queremos agregar otra acción, solo necesitamos definir su función y modificar la `move_money`función. También podemos probar fácilmente componentes separados ya que se determinan en funciones separadas. Con todo, nuestro programa ahora es un programa de funcionamiento real que no se derrumbará cuando decidamos cambiarlo un poco.

##### Resumen

En este tema, hemos cubierto el concepto de descomposición funcional, dividiendo el proceso en varias funciones.

Entre otras cosas, la descomposición nos permite:

- estructurar mejor el código;
- ver la lógica general del programa;
- introducir cambios fácilmente;
- probar funciones separadas.

Evidentemente, la descomposición funcional no es una solución universal. Sin embargo, si puede pensar en su problema en términos de una secuencia de algunas funciones, ¡puede ser de gran ayuda para usted!

```python
name1 = "John"
last_name1 = "Lennon"
full_name1 = name1 + " " + last_name1
        
name2 = "Hermione"
last_name2 = "Granger"
full_name2 = name2 + " " + last_name2

###

def create_full_name(name, last_name):
    return f'{name} {last_name}'

```

```python

def main():
    temperature, unit = input().split()
    unit = str(unit)
    temperature = float(temperature)
    if unit == "C":
        unit = "F"
        print(str(celsius_to_fahrenheit(temperature)), "F")
    else:
        unit = "C"
        print(str(fahrenheit_to_celsius(temperature)), "C")

if __name__ == '__main__':
    main()
 
 ```
``
